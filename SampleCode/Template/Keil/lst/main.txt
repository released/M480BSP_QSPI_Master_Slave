; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_QSPI_MASTER --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;471    
;;;472    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;473    {
;;;474    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;475    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;476    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;477    	
;;;478    }
;;;479    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;328    
;;;329    void PDMA_IRQHandler(void)
000000  491b              LDR      r1,|L3.112|
;;;330    {
000002  b510              PUSH     {r4,lr}
;;;331    	#if defined (ENABLE_QSPI_MASTER)	
;;;332        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000004  6808              LDR      r0,[r1,#0]
;;;333    	
;;;334        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000006  07c2              LSLS     r2,r0,#31
000008  d003              BEQ      |L3.18|
;;;335        {
;;;336    		#if 1
;;;337            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
00000a  1d08              ADDS     r0,r1,#4
00000c  6801              LDR      r1,[r0,#0]
00000e  6001              STR      r1,[r0,#0]
                  |L3.16|
;;;338    		#else
;;;339            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_MASTER_TX_DMA_CH))
;;;340            {
;;;341    
;;;342            }
;;;343            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_MASTER_TX_DMA_CH));
;;;344    
;;;345            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_MASTER_RX_DMA_CH))
;;;346            {
;;;347    
;;;348            }
;;;349            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_MASTER_RX_DMA_CH));
;;;350    		#endif
;;;351        }
;;;352        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;353        {
;;;354            if((PDMA_GET_TD_STS(PDMA) & QSPI_MASTER_OPENED_CH) == QSPI_MASTER_OPENED_CH)
;;;355            {
;;;356                /* Clear PDMA transfer done interrupt flag */
;;;357                PDMA_CLR_TD_FLAG(PDMA, QSPI_MASTER_OPENED_CH);
;;;358    
;;;359    			//insert process
;;;360    			QSPI_DISABLE_TX_PDMA(QSPI0);
;;;361    			QSPI_DISABLE_RX_PDMA(QSPI0);
;;;362    			LED_Y ^= 1;
;;;363    			QSPI_Master_PDMA_Enable(QSPI_TX);
;;;364    			QSPI_Master_PDMA_Enable(QSPI_RX);
;;;365            }        		
;;;366        }
;;;367        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;368        {
;;;369    		LED_G ^= 1;
;;;370            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_MASTER_TX_DMA_CH);
;;;371            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_MASTER_RX_DMA_CH);
;;;372        }
;;;373        else
;;;374        {
;;;375    
;;;376        }
;;;377    
;;;378    	#elif defined (ENABLE_QSPI_SLAVE)
;;;379        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
;;;380    	
;;;381        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
;;;382        {
;;;383    		#if 1
;;;384            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
;;;385    		#else
;;;386            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_SLAVE_TX_DMA_CH))
;;;387            {
;;;388    
;;;389            }
;;;390            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_SLAVE_TX_DMA_CH));
;;;391    
;;;392            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_SLAVE_RX_DMA_CH))
;;;393            {
;;;394    
;;;395            }
;;;396            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_SLAVE_RX_DMA_CH));
;;;397    		#endif
;;;398        }
;;;399        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;400        {
;;;401            if((PDMA_GET_TD_STS(PDMA) & QSPI_SLAVE_OPENED_CH) == QSPI_SLAVE_OPENED_CH)
;;;402            {
;;;403                /* Clear PDMA transfer done interrupt flag */
;;;404                PDMA_CLR_TD_FLAG(PDMA, QSPI_SLAVE_OPENED_CH);
;;;405    
;;;406    			//insert process
;;;407    			QSPI_DISABLE_TX_PDMA(QSPI0);
;;;408    			QSPI_DISABLE_RX_PDMA(QSPI0);			
;;;409    			LED_Y ^= 1;
;;;410    			QSPI_Slave_PDMA_Enable(QSPI_TX);
;;;411    			QSPI_Slave_PDMA_Enable(QSPI_RX);			
;;;412            }        		
;;;413        }
;;;414        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;415        {
;;;416    		LED_G ^= 1;
;;;417            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_SLAVE_TX_DMA_CH);
;;;418            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_SLAVE_RX_DMA_CH);
;;;419        }
;;;420        else
;;;421        {
;;;422    
;;;423        }
;;;424    
;;;425    	#endif
;;;426    	
;;;427    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  0782              LSLS     r2,r0,#30             ;352
000014  d51d              BPL      |L3.82|
000016  4816              LDR      r0,|L3.112|
000018  3008              ADDS     r0,r0,#8              ;354
00001a  6801              LDR      r1,[r0,#0]            ;354
00001c  43c9              MVNS     r1,r1                 ;354
00001e  0789              LSLS     r1,r1,#30             ;354
000020  d1f6              BNE      |L3.16|
000022  2103              MOVS     r1,#3                 ;357
000024  6001              STR      r1,[r0,#0]            ;357
000026  4813              LDR      r0,|L3.116|
000028  68c1              LDR      r1,[r0,#0xc]          ;360
00002a  f0210101          BIC      r1,r1,#1              ;360
00002e  60c1              STR      r1,[r0,#0xc]          ;360
000030  68c1              LDR      r1,[r0,#0xc]          ;361
000032  f0210102          BIC      r1,r1,#2              ;361
000036  60c1              STR      r1,[r0,#0xc]          ;361
000038  480f              LDR      r0,|L3.120|
00003a  6801              LDR      r1,[r0,#0]            ;362
00003c  f0810101          EOR      r1,r1,#1              ;362
000040  6001              STR      r1,[r0,#0]            ;362
000042  2000              MOVS     r0,#0                 ;363
000044  f7fffffe          BL       QSPI_Master_PDMA_Enable
000048  e8bd4010          POP      {r4,lr}               ;364
00004c  2001              MOVS     r0,#1                 ;364
00004e  f7ffbffe          B.W      QSPI_Master_PDMA_Enable
                  |L3.82|
000052  f4107f40          TST      r0,#0x300             ;367
000056  d0db              BEQ      |L3.16|
000058  4807              LDR      r0,|L3.120|
00005a  1d00              ADDS     r0,r0,#4              ;369
00005c  6802              LDR      r2,[r0,#0]            ;369
00005e  f0820201          EOR      r2,r2,#1              ;369
000062  6002              STR      r2,[r0,#0]            ;369
000064  1580              ASRS     r0,r0,#22             ;370
000066  6008              STR      r0,[r1,#0]            ;370
000068  0040              LSLS     r0,r0,#1              ;371
00006a  6008              STR      r0,[r1,#0]            ;371
00006c  bd10              POP      {r4,pc}
;;;428    
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0x4000841c
                  |L3.116|
                          DCD      0x40060000
                  |L3.120|
                          DCD      0x400049c4

                          AREA ||i.QSPI_Master_Init||, CODE, READONLY, ALIGN=2

                  QSPI_Master_Init PROC
;;;319    */
;;;320    void QSPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;321    {
;;;322        QSPI_Open(QSPI0, QSPI_MASTER, QSPI_MODE_0, 8, QSPI_TARGET_FREQ);
000002  4808              LDR      r0,|L4.36|
000004  4c08              LDR      r4,|L4.40|
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       QSPI_Open
;;;323    
;;;324        /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;325        QSPI_EnableAutoSS(QSPI0, QSPI_SS, QSPI_SS_ACTIVE_LOW);
000014  4620              MOV      r0,r4
000016  e8bd4038          POP      {r3-r5,lr}
00001a  2200              MOVS     r2,#0
00001c  2101              MOVS     r1,#1
00001e  f7ffbffe          B.W      QSPI_EnableAutoSS
;;;326    }
;;;327    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x000186a0
                  |L4.40|
                          DCD      0x40060000

                          AREA ||i.QSPI_Master_PDMA_ClrBuffer||, CODE, READONLY, ALIGN=2

                  QSPI_Master_PDMA_ClrBuffer PROC
;;;181    
;;;182    void QSPI_Master_PDMA_ClrBuffer(uint8_t TxRx)
000000  2100              MOVS     r1,#0
;;;183    {
;;;184        uint16_t i = 0;
;;;185    
;;;186    	if (TxRx == QSPI_TX)
;;;187    	{
;;;188    	    for (i = 0; i < DATA_NUM; i++)
;;;189    	    {
;;;190    	        g_au8MasterToSlaveTestPattern[i] = 0xFF;
000002  22ff              MOVS     r2,#0xff
000004  b130              CBZ      r0,|L5.20|
;;;191    	    }
;;;192    	}
;;;193    	else
;;;194    	{
;;;195    	    for (i = 0; i < DATA_NUM; i++)
;;;196    	    {
;;;197    	        g_au8MasterRxBuffer[i] = 0xFF;
000006  4807              LDR      r0,|L5.36|
                  |L5.8|
000008  5442              STRB     r2,[r0,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  b289              UXTH     r1,r1                 ;195
00000e  2910              CMP      r1,#0x10              ;195
000010  d3fa              BCC      |L5.8|
;;;198    	    }
;;;199    	}
;;;200    }
000012  4770              BX       lr
                  |L5.20|
000014  4803              LDR      r0,|L5.36|
000016  3820              SUBS     r0,r0,#0x20           ;190
                  |L5.24|
000018  5442              STRB     r2,[r0,r1]            ;190
00001a  1c49              ADDS     r1,r1,#1              ;190
00001c  b289              UXTH     r1,r1                 ;188
00001e  2910              CMP      r1,#0x10              ;188
000020  d3fa              BCC      |L5.24|
000022  4770              BX       lr
;;;201    
                          ENDP

                  |L5.36|
                          DCD      ||.bss||+0x20

                          AREA ||i.QSPI_Master_PDMA_Enable||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  QSPI_Master_PDMA_Enable PROC
;;;245    
;;;246    void QSPI_Master_PDMA_Enable(uint8_t TxRx)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;247    {
;;;248        uint16_t i = 0;
000004  2400              MOVS     r4,#0
;;;249        static uint8_t k = 0x10;
;;;250    	
;;;251    	if (TxRx == QSPI_TX)
;;;252    	{
;;;253    		QSPI_Master_PDMA_ClrBuffer(QSPI_TX);
;;;254    	
;;;255    		//prepare master TX data
;;;256    		g_au8MasterToSlaveTestPattern[INDEX_HEAD] = DATA_HEAD_MASTER;
;;;257    		g_au8MasterToSlaveTestPattern[INDEX_TAIL] = DATA_TAIL_MASTER;
;;;258    
;;;259    	    for (i = (INDEX_HEAD+1); i < INDEX_TAIL ; i++)
;;;260    	    {
;;;261    	        g_au8MasterToSlaveTestPattern[i] = (i + k);
;;;262    	    }
;;;263    
;;;264    		k += 0x10;
;;;265    		if (k >= 0xFF)
;;;266    		{
;;;267    			k = 0x10;
;;;268    		}
;;;269    
;;;270    		#if 1	//TX debug
;;;271    		printf("\r\ng_au8MasterToSlaveTestPattern : \r\n");
;;;272    		for (i = 0 ; i < DATA_NUM ; i++)
;;;273    		{
;;;274    			printf("0x%2X," , g_au8MasterToSlaveTestPattern[i]);
;;;275                if ((i+1)%8 ==0)
;;;276                {
;;;277                    printf("\r\n");
;;;278                }			
;;;279    		}
;;;280    		#endif
;;;281    	
;;;282    		//TX
;;;283    	    PDMA_SetTransferCnt(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000006  4e3e              LDR      r6,|L6.256|
;;;284    		PDMA_SetTransferAddr(PDMA,QSPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);		
;;;285    	    /* Set request source; set basic mode. */
;;;286    	    PDMA_SetTransferMode(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
;;;287    	    QSPI_TRIGGER_TX_PDMA(QSPI0);	
000008  4d3e              LDR      r5,|L6.260|
00000a  46a0              MOV      r8,r4                 ;248
00000c  b1f0              CBZ      r0,|L6.76|
;;;288    	}
;;;289    	else
;;;290    	{
;;;291    		//RX	
;;;292    		PDMA_SetTransferCnt(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
00000e  2310              MOVS     r3,#0x10
000010  2200              MOVS     r2,#0
000012  2101              MOVS     r1,#1
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       PDMA_SetTransferCnt
;;;293    		/* Set request source; set basic mode. */
;;;294    		PDMA_SetTransferMode(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00001a  2300              MOVS     r3,#0
00001c  2215              MOVS     r2,#0x15
00001e  2101              MOVS     r1,#1
000020  4630              MOV      r0,r6
000022  f8cd8000          STR      r8,[sp,#0]
000026  f7fffffe          BL       PDMA_SetTransferMode
;;;295    		QSPI_TRIGGER_RX_PDMA(QSPI0);
00002a  68e8              LDR      r0,[r5,#0xc]
00002c  f0400002          ORR      r0,r0,#2
000030  60e8              STR      r0,[r5,#0xc]
;;;296    
;;;297    		#if 1	//RX debug
;;;298    		printf("\r\ng_au8MasterRxBuffer : \r\n");
000032  a035              ADR      r0,|L6.264|
000034  f7fffffe          BL       __2printf
;;;299    		for (i = 0 ; i < DATA_NUM ; i++)
;;;300    		{
;;;301    			printf("0x%2X," , g_au8MasterRxBuffer[i]);
000038  4d3a              LDR      r5,|L6.292|
                  |L6.58|
00003a  a03b              ADR      r0,|L6.296|
00003c  5d29              LDRB     r1,[r5,r4]
00003e  f7fffffe          BL       __2printf
;;;302                if ((i+1)%8 ==0)
000042  0760              LSLS     r0,r4,#29
000044  f1b04f60          CMP      r0,#0xe0000000
000048  d04d              BEQ      |L6.230|
00004a  e04f              B        |L6.236|
                  |L6.76|
00004c  2000              MOVS     r0,#0                 ;253
00004e  f7fffffe          BL       QSPI_Master_PDMA_ClrBuffer
000052  4f34              LDR      r7,|L6.292|
000054  2030              MOVS     r0,#0x30              ;256
000056  3f20              SUBS     r7,r7,#0x20           ;256
000058  4b35              LDR      r3,|L6.304|
00005a  7038              STRB     r0,[r7,#0]            ;256
00005c  2036              MOVS     r0,#0x36              ;257
00005e  73f8              STRB     r0,[r7,#0xf]          ;257
000060  7819              LDRB     r1,[r3,#0]            ;261
000062  2001              MOVS     r0,#1                 ;259
                  |L6.100|
000064  1842              ADDS     r2,r0,r1              ;261
000066  543a              STRB     r2,[r7,r0]            ;261
000068  1c40              ADDS     r0,r0,#1              ;261
00006a  b280              UXTH     r0,r0                 ;259
00006c  280f              CMP      r0,#0xf               ;259
00006e  d3f9              BCC      |L6.100|
000070  3110              ADDS     r1,r1,#0x10           ;259
000072  b2c8              UXTB     r0,r1                 ;264
000074  7018              STRB     r0,[r3,#0]            ;264
000076  28ff              CMP      r0,#0xff              ;265
000078  d301              BCC      |L6.126|
00007a  2010              MOVS     r0,#0x10              ;267
00007c  7018              STRB     r0,[r3,#0]            ;267
                  |L6.126|
00007e  a02d              ADR      r0,|L6.308|
000080  f7fffffe          BL       __2printf
000084  2400              MOVS     r4,#0                 ;272
                  |L6.134|
000086  a028              ADR      r0,|L6.296|
000088  5d39              LDRB     r1,[r7,r4]            ;274
00008a  f7fffffe          BL       __2printf
00008e  0760              LSLS     r0,r4,#29             ;275
000090  f1b04f60          CMP      r0,#0xe0000000        ;275
000094  d102              BNE      |L6.156|
000096  a022              ADR      r0,|L6.288|
000098  f7fffffe          BL       __2printf
                  |L6.156|
00009c  1c64              ADDS     r4,r4,#1              ;277
00009e  b2a4              UXTH     r4,r4                 ;272
0000a0  2c10              CMP      r4,#0x10              ;272
0000a2  d3f0              BCC      |L6.134|
0000a4  2200              MOVS     r2,#0                 ;283
0000a6  2310              MOVS     r3,#0x10              ;283
0000a8  4611              MOV      r1,r2                 ;283
0000aa  4630              MOV      r0,r6                 ;283
0000ac  f7fffffe          BL       PDMA_SetTransferCnt
0000b0  4814              LDR      r0,|L6.260|
0000b2  f44f6140          MOV      r1,#0xc00             ;284
0000b6  3020              ADDS     r0,r0,#0x20           ;284
0000b8  4a1a              LDR      r2,|L6.292|
0000ba  e9cd0100          STRD     r0,r1,[sp,#0]         ;284
0000be  2300              MOVS     r3,#0                 ;284
0000c0  3a20              SUBS     r2,r2,#0x20           ;284
0000c2  4619              MOV      r1,r3                 ;284
0000c4  4630              MOV      r0,r6                 ;284
0000c6  f7fffffe          BL       PDMA_SetTransferAddr
0000ca  2300              MOVS     r3,#0                 ;286
0000cc  2214              MOVS     r2,#0x14              ;286
0000ce  4619              MOV      r1,r3                 ;286
0000d0  4630              MOV      r0,r6                 ;286
0000d2  f8cd8000          STR      r8,[sp,#0]            ;286
0000d6  f7fffffe          BL       PDMA_SetTransferMode
0000da  68e8              LDR      r0,[r5,#0xc]          ;287
0000dc  f0400001          ORR      r0,r0,#1              ;287
0000e0  60e8              STR      r0,[r5,#0xc]          ;287
;;;303                {
;;;304                    printf("\r\n");
;;;305                }			
;;;306    		}
;;;307    		#endif
;;;308    
;;;309    		QSPI_Master_PDMA_ClrBuffer(QSPI_RX);			
;;;310    	}
;;;311    }
0000e2  e8bd81fc          POP      {r2-r8,pc}
                  |L6.230|
0000e6  a00e              ADR      r0,|L6.288|
0000e8  f7fffffe          BL       __2printf
                  |L6.236|
0000ec  1c64              ADDS     r4,r4,#1              ;304
0000ee  b2a4              UXTH     r4,r4                 ;299
0000f0  2c10              CMP      r4,#0x10              ;299
0000f2  d3a2              BCC      |L6.58|
0000f4  e8bd41fc          POP      {r2-r8,lr}            ;309
0000f8  2001              MOVS     r0,#1                 ;309
0000fa  f7ffbffe          B.W      QSPI_Master_PDMA_ClrBuffer
;;;312    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L6.256|
                          DCD      0x40008000
                  |L6.260|
                          DCD      0x40060000
                  |L6.264|
000108  0d0a675f          DCB      "\r\ng_au8MasterRxBuffer : "
00010c  6175384d
000110  61737465
000114  72527842
000118  75666665
00011c  72203a20
                  |L6.288|
000120  0d0a00            DCB      "\r\n",0
000123  00                DCB      0
                  |L6.292|
                          DCD      ||.bss||+0x20
                  |L6.296|
000128  30782532          DCB      "0x%2X,",0
00012c  582c00  
00012f  00                DCB      0
                  |L6.304|
                          DCD      ||.data||
                  |L6.308|
000134  0d0a675f          DCB      "\r\ng_au8MasterToSlaveTestPattern : \r\n",0
000138  6175384d
00013c  61737465
000140  72546f53
000144  6c617665
000148  54657374
00014c  50617474
000150  65726e20
000154  3a200d0a
000158  00      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0

                          AREA ||i.QSPI_Master_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  QSPI_Master_PDMA_PreInit PROC
;;;201    
;;;202    void QSPI_Master_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;203    {
;;;204        uint16_t i = 0;
;;;205    	
;;;206    	//prepare data
;;;207        for (i=0; i < DATA_NUM; i++)
;;;208        {
;;;209            g_au8MasterToSlaveTestPattern[i] = i;
000002  4a36              LDR      r2,|L7.220|
000004  2000              MOVS     r0,#0                 ;204
;;;210            g_au8MasterRxBuffer[i] = 0xFF;
000006  21ff              MOVS     r1,#0xff
000008  f1020420          ADD      r4,r2,#0x20
                  |L7.12|
00000c  5410              STRB     r0,[r2,r0]            ;209
00000e  5421              STRB     r1,[r4,r0]
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0                 ;207
000014  2810              CMP      r0,#0x10              ;207
000016  d3f9              BCC      |L7.12|
;;;211        }
;;;212    
;;;213        PDMA_Open(PDMA, QSPI_MASTER_OPENED_CH);
000018  4d31              LDR      r5,|L7.224|
00001a  2103              MOVS     r1,#3
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       PDMA_Open
;;;214    
;;;215    	//TX
;;;216        PDMA_SetTransferCnt(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000022  2200              MOVS     r2,#0
000024  2310              MOVS     r3,#0x10
000026  4611              MOV      r1,r2
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferCnt
;;;217        /* Set source/destination address and attributes */
;;;218        PDMA_SetTransferAddr(PDMA,QSPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);
00002e  f44f6140          MOV      r1,#0xc00
000032  482c              LDR      r0,|L7.228|
000034  e9cd0100          STRD     r0,r1,[sp,#0]
000038  2300              MOVS     r3,#0
00003a  4a28              LDR      r2,|L7.220|
00003c  4619              MOV      r1,r3
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       PDMA_SetTransferAddr
;;;219        /* Set request source; set basic mode. */
;;;220        PDMA_SetTransferMode(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
000044  2600              MOVS     r6,#0
000046  4633              MOV      r3,r6
000048  2214              MOVS     r2,#0x14
00004a  4631              MOV      r1,r6
00004c  4628              MOV      r0,r5
00004e  9600              STR      r6,[sp,#0]
000050  f7fffffe          BL       PDMA_SetTransferMode
;;;221        /* Single request type. SPI only support PDMA single request type. */
;;;222        PDMA_SetBurstType(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000054  2300              MOVS     r3,#0
000056  2204              MOVS     r2,#4
000058  4619              MOV      r1,r3
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       PDMA_SetBurstType
;;;223        /* Disable table interrupt */
;;;224        PDMA->DSCT[QSPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000060  6828              LDR      r0,[r5,#0]
000062  f0400080          ORR      r0,r0,#0x80
000066  6028              STR      r0,[r5,#0]
;;;225    
;;;226    	//RX	
;;;227        PDMA_SetTransferCnt(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000068  2310              MOVS     r3,#0x10
00006a  2200              MOVS     r2,#0
00006c  2101              MOVS     r1,#1
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       PDMA_SetTransferCnt
;;;228        /* Set source/destination address and attributes */
;;;229        PDMA_SetTransferAddr(PDMA,QSPI_MASTER_RX_DMA_CH, (uint32_t)&QSPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8MasterRxBuffer, PDMA_DAR_INC);
000074  4a1b              LDR      r2,|L7.228|
000076  e9cd4600          STRD     r4,r6,[sp,#0]
00007a  f44f7340          MOV      r3,#0x300
00007e  3210              ADDS     r2,r2,#0x10
000080  2101              MOVS     r1,#1
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       PDMA_SetTransferAddr
;;;230        /* Set request source; set basic mode. */
;;;231        PDMA_SetTransferMode(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
000088  2300              MOVS     r3,#0
00008a  2215              MOVS     r2,#0x15
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  9600              STR      r6,[sp,#0]
000092  f7fffffe          BL       PDMA_SetTransferMode
;;;232        /* Single request type. SPI only support PDMA single request type. */
;;;233        PDMA_SetBurstType(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000096  2300              MOVS     r3,#0
000098  2204              MOVS     r2,#4
00009a  2101              MOVS     r1,#1
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       PDMA_SetBurstType
;;;234        /* Disable table interrupt */
;;;235        PDMA->DSCT[QSPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
0000a2  6928              LDR      r0,[r5,#0x10]
0000a4  f0400080          ORR      r0,r0,#0x80
0000a8  6128              STR      r0,[r5,#0x10]
;;;236    
;;;237        QSPI_TRIGGER_RX_PDMA(QSPI0);
0000aa  480e              LDR      r0,|L7.228|
0000ac  3820              SUBS     r0,r0,#0x20
0000ae  68c1              LDR      r1,[r0,#0xc]
0000b0  f0410102          ORR      r1,r1,#2
0000b4  60c1              STR      r1,[r0,#0xc]
;;;238        QSPI_TRIGGER_TX_PDMA(QSPI0);
0000b6  68c1              LDR      r1,[r0,#0xc]
0000b8  f0410101          ORR      r1,r1,#1
0000bc  60c1              STR      r1,[r0,#0xc]
;;;239    
;;;240        PDMA_EnableInt(PDMA, QSPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);
0000be  2200              MOVS     r2,#0
0000c0  4611              MOV      r1,r2
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       PDMA_EnableInt
;;;241        PDMA_EnableInt(PDMA, QSPI_MASTER_RX_DMA_CH, PDMA_INT_TRANS_DONE);
0000c8  2200              MOVS     r2,#0
0000ca  2101              MOVS     r1,#1
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       PDMA_EnableInt
;;;242        NVIC_EnableIRQ(PDMA_IRQn);
0000d2  e8bd407c          POP      {r2-r6,lr}
0000d6  2028              MOVS     r0,#0x28
0000d8  f7ffbffe          B.W      NVIC_EnableIRQ
;;;243    	
;;;244    }
;;;245    
                          ENDP

                  |L7.220|
                          DCD      ||.bss||
                  |L7.224|
                          DCD      0x40008000
                  |L7.228|
                          DCD      0x40060020

                          AREA ||i.QSPI_Slave_Init||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_Init PROC
;;;175    
;;;176    void QSPI_Slave_Init(void)
000000  b508              PUSH     {r3,lr}
;;;177    {
;;;178        QSPI_Open(QSPI0, QSPI_SLAVE, QSPI_MODE_0, 8, (uint32_t)NULL);
000002  2000              MOVS     r0,#0
000004  2204              MOVS     r2,#4
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  0411              LSLS     r1,r2,#16
00000c  4801              LDR      r0,|L8.20|
00000e  f7fffffe          BL       QSPI_Open
;;;179    }
000012  bd08              POP      {r3,pc}
;;;180    
                          ENDP

                  |L8.20|
                          DCD      0x40060000

                          AREA ||i.QSPI_Slave_PDMA_ClrBuffer||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_PDMA_ClrBuffer PROC
;;;46     
;;;47     void QSPI_Slave_PDMA_ClrBuffer(uint8_t TxRx)
000000  2100              MOVS     r1,#0
;;;48     {
;;;49         uint16_t i = 0;
;;;50     
;;;51     	if (TxRx == QSPI_TX)
;;;52     	{
;;;53     	    for (i = 0; i < DATA_NUM; i++)
;;;54     	    {
;;;55     	        g_au8SlaveToMasterTestPattern[i] = 0xFF;
000002  22ff              MOVS     r2,#0xff
000004  b130              CBZ      r0,|L9.20|
;;;56     	    }
;;;57     	}
;;;58     	else
;;;59     	{
;;;60     	    for (i = 0; i < DATA_NUM; i++)
;;;61     	    {
;;;62     	        g_au8SlaveRxBuffer[i] = 0xFF;
000006  4807              LDR      r0,|L9.36|
                  |L9.8|
000008  5442              STRB     r2,[r0,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  b289              UXTH     r1,r1                 ;60
00000e  2910              CMP      r1,#0x10              ;60
000010  d3fa              BCC      |L9.8|
;;;63     	    }
;;;64     	}
;;;65     }
000012  4770              BX       lr
                  |L9.20|
000014  4803              LDR      r0,|L9.36|
000016  3820              SUBS     r0,r0,#0x20           ;55
                  |L9.24|
000018  5442              STRB     r2,[r0,r1]            ;55
00001a  1c49              ADDS     r1,r1,#1              ;55
00001c  b289              UXTH     r1,r1                 ;53
00001e  2910              CMP      r1,#0x10              ;53
000020  d3fa              BCC      |L9.24|
000022  4770              BX       lr
;;;66     
                          ENDP

                  |L9.36|
                          DCD      ||.bss||+0x30

                          AREA ||i.QSPI_Slave_PDMA_Enable||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  QSPI_Slave_PDMA_Enable PROC
;;;104    
;;;105    void QSPI_Slave_PDMA_Enable(uint8_t TxRx)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;106    {
;;;107        uint16_t i = 0;
000004  2500              MOVS     r5,#0
;;;108    
;;;109    	if (TxRx == QSPI_TX)
;;;110    	{		
;;;111    		QSPI_Slave_PDMA_ClrBuffer(QSPI_TX);		
;;;112    
;;;113    		//prepare slave TX data
;;;114    		if ((g_au8SlaveRxBuffer[INDEX_HEAD] == DATA_HEAD_MASTER)&& 
;;;115    			(g_au8SlaveRxBuffer[INDEX_TAIL] == DATA_TAIL_MASTER))
;;;116    		{
;;;117    
;;;118    			g_au8SlaveToMasterTestPattern[INDEX_HEAD] = DATA_HEAD_SLAVE;
;;;119    			g_au8SlaveToMasterTestPattern[INDEX_TAIL] = DATA_TAIL_SLAVE;
;;;120    
;;;121    		    for (i = (INDEX_HEAD+1); i < INDEX_TAIL; i++)
;;;122    		    {
;;;123    		        g_au8SlaveToMasterTestPattern[INDEX_TAIL-i] = g_au8SlaveRxBuffer[i];
;;;124    		    }
;;;125    			
;;;126    //		    for (i = (INDEX_HEAD+1); i < INDEX_TAIL; i++)
;;;127    //		    {
;;;128    //		        g_au8SlaveToMasterTestPattern[i] = i;
;;;129    //		    }
;;;130    		}
;;;131    
;;;132    		#if 1	//TX debug
;;;133    		printf("\r\ng_au8SlaveToMasterTestPattern : \r\n");
;;;134    		for (i = 0 ; i < DATA_NUM ; i++)
;;;135    		{
;;;136    			printf("0x%2X," , g_au8SlaveToMasterTestPattern[i]);
;;;137                if ((i+1)%8 ==0)
;;;138                {
;;;139                    printf("\r\n");
;;;140                }			
;;;141    		}
;;;142    		#endif			
;;;143    	
;;;144    		//TX
;;;145    	    PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000006  4f3d              LDR      r7,|L10.252|
;;;146       	 	PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_TX_DMA_CH, (uint32_t)g_au8SlaveToMasterTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);		
;;;147    	    /* Set request source; set basic mode. */
;;;148    	    PDMA_SetTransferMode(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
;;;149    	    QSPI_TRIGGER_TX_PDMA(QSPI0);		
000008  4e3d              LDR      r6,|L10.256|
00000a  4c3e              LDR      r4,|L10.260|
00000c  46a8              MOV      r8,r5                 ;107
00000e  b1e8              CBZ      r0,|L10.76|
;;;150    
;;;151    	}
;;;152    	else
;;;153    	{		
;;;154    		//RX
;;;155    	    PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000010  2310              MOVS     r3,#0x10
000012  2200              MOVS     r2,#0
000014  2103              MOVS     r1,#3
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;156    	    /* Set request source; set basic mode. */
;;;157    	    PDMA_SetTransferMode(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00001c  2300              MOVS     r3,#0
00001e  2215              MOVS     r2,#0x15
000020  2103              MOVS     r1,#3
000022  4638              MOV      r0,r7
000024  f8cd8000          STR      r8,[sp,#0]
000028  f7fffffe          BL       PDMA_SetTransferMode
;;;158    	    QSPI_TRIGGER_RX_PDMA(QSPI0);	
00002c  68f0              LDR      r0,[r6,#0xc]
00002e  f0400002          ORR      r0,r0,#2
000032  60f0              STR      r0,[r6,#0xc]
;;;159    
;;;160    		#if 1	//RX debug
;;;161    		printf("\r\ng_au8SlaveRxBuffer : \r\n");
000034  a034              ADR      r0,|L10.264|
000036  f7fffffe          BL       __2printf
                  |L10.58|
;;;162    		for (i = 0 ; i < DATA_NUM ; i++)
;;;163    		{
;;;164    			printf("0x%2X," , g_au8SlaveRxBuffer[i]);
00003a  5d61              LDRB     r1,[r4,r5]
00003c  a039              ADR      r0,|L10.292|
00003e  f7fffffe          BL       __2printf
;;;165                if ((i+1)%8 ==0)
000042  0768              LSLS     r0,r5,#29
000044  f1b04f60          CMP      r0,#0xe0000000
000048  d04c              BEQ      |L10.228|
00004a  e04e              B        |L10.234|
                  |L10.76|
00004c  2000              MOVS     r0,#0                 ;111
00004e  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
000052  4d2c              LDR      r5,|L10.260|
000054  7820              LDRB     r0,[r4,#0]            ;114  ; g_au8SlaveRxBuffer
000056  3d20              SUBS     r5,r5,#0x20           ;118
000058  2830              CMP      r0,#0x30              ;114
00005a  d10f              BNE      |L10.124|
00005c  7be0              LDRB     r0,[r4,#0xf]          ;115  ; g_au8SlaveRxBuffer
00005e  2836              CMP      r0,#0x36              ;115
000060  d10c              BNE      |L10.124|
000062  2055              MOVS     r0,#0x55              ;118
000064  7028              STRB     r0,[r5,#0]            ;118
000066  2066              MOVS     r0,#0x66              ;119
000068  73e8              STRB     r0,[r5,#0xf]          ;119
00006a  2001              MOVS     r0,#1                 ;121
                  |L10.108|
00006c  f1c0020f          RSB      r2,r0,#0xf            ;123
000070  5c21              LDRB     r1,[r4,r0]            ;123
000072  1c40              ADDS     r0,r0,#1              ;123
000074  b280              UXTH     r0,r0                 ;121
000076  54a9              STRB     r1,[r5,r2]            ;123
000078  280f              CMP      r0,#0xf               ;121
00007a  d3f7              BCC      |L10.108|
                  |L10.124|
00007c  a02b              ADR      r0,|L10.300|
00007e  f7fffffe          BL       __2printf
000082  2400              MOVS     r4,#0                 ;134
                  |L10.132|
000084  a027              ADR      r0,|L10.292|
000086  5d29              LDRB     r1,[r5,r4]            ;136
000088  f7fffffe          BL       __2printf
00008c  0760              LSLS     r0,r4,#29             ;137
00008e  f1b04f60          CMP      r0,#0xe0000000        ;137
000092  d102              BNE      |L10.154|
000094  a02f              ADR      r0,|L10.340|
000096  f7fffffe          BL       __2printf
                  |L10.154|
00009a  1c64              ADDS     r4,r4,#1              ;139
00009c  b2a4              UXTH     r4,r4                 ;134
00009e  2c10              CMP      r4,#0x10              ;134
0000a0  d3f0              BCC      |L10.132|
0000a2  2310              MOVS     r3,#0x10              ;145
0000a4  2200              MOVS     r2,#0                 ;145
0000a6  2102              MOVS     r1,#2                 ;145
0000a8  4638              MOV      r0,r7                 ;145
0000aa  f7fffffe          BL       PDMA_SetTransferCnt
0000ae  4814              LDR      r0,|L10.256|
0000b0  f44f6140          MOV      r1,#0xc00             ;146
0000b4  3020              ADDS     r0,r0,#0x20           ;146
0000b6  4a13              LDR      r2,|L10.260|
0000b8  e9cd0100          STRD     r0,r1,[sp,#0]         ;146
0000bc  2300              MOVS     r3,#0                 ;146
0000be  3a20              SUBS     r2,r2,#0x20           ;146
0000c0  2102              MOVS     r1,#2                 ;146
0000c2  4638              MOV      r0,r7                 ;146
0000c4  f7fffffe          BL       PDMA_SetTransferAddr
0000c8  2300              MOVS     r3,#0                 ;148
0000ca  2214              MOVS     r2,#0x14              ;148
0000cc  2102              MOVS     r1,#2                 ;148
0000ce  4638              MOV      r0,r7                 ;148
0000d0  f8cd8000          STR      r8,[sp,#0]            ;148
0000d4  f7fffffe          BL       PDMA_SetTransferMode
0000d8  68f0              LDR      r0,[r6,#0xc]          ;149
0000da  f0400001          ORR      r0,r0,#1              ;149
0000de  60f0              STR      r0,[r6,#0xc]          ;149
;;;166                {
;;;167                    printf("\r\n");
;;;168                }			
;;;169    		}
;;;170    		#endif
;;;171    
;;;172    		QSPI_Slave_PDMA_ClrBuffer(QSPI_RX);	
;;;173    	}
;;;174    }
0000e0  e8bd81fc          POP      {r2-r8,pc}
                  |L10.228|
0000e4  a01b              ADR      r0,|L10.340|
0000e6  f7fffffe          BL       __2printf
                  |L10.234|
0000ea  1c6d              ADDS     r5,r5,#1              ;167
0000ec  b2ad              UXTH     r5,r5                 ;162
0000ee  2d10              CMP      r5,#0x10              ;162
0000f0  d3a3              BCC      |L10.58|
0000f2  e8bd41fc          POP      {r2-r8,lr}            ;172
0000f6  2001              MOVS     r0,#1                 ;172
0000f8  f7ffbffe          B.W      QSPI_Slave_PDMA_ClrBuffer
;;;175    
                          ENDP

                  |L10.252|
                          DCD      0x40008000
                  |L10.256|
                          DCD      0x40060000
                  |L10.260|
                          DCD      ||.bss||+0x30
                  |L10.264|
000108  0d0a675f          DCB      "\r\ng_au8SlaveRxBuffer : \r\n",0
00010c  61753853
000110  6c617665
000114  52784275
000118  66666572
00011c  203a200d
000120  0a00    
000122  00                DCB      0
000123  00                DCB      0
                  |L10.292|
000124  30782532          DCB      "0x%2X,",0
000128  582c00  
00012b  00                DCB      0
                  |L10.300|
00012c  0d0a675f          DCB      "\r\ng_au8SlaveToMasterTestPattern : \r\n",0
000130  61753853
000134  6c617665
000138  546f4d61
00013c  73746572
000140  54657374
000144  50617474
000148  65726e20
00014c  3a200d0a
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L10.340|
000154  0d0a00            DCB      "\r\n",0
000157  00                DCB      0

                          AREA ||i.QSPI_Slave_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_PDMA_PreInit PROC
;;;66     
;;;67     void QSPI_Slave_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;68     {
;;;69     	QSPI_Slave_PDMA_ClrBuffer(QSPI_TX);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
;;;70     	QSPI_Slave_PDMA_ClrBuffer(QSPI_RX);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
;;;71     	
;;;72         PDMA_Open(PDMA, QSPI_SLAVE_OPENED_CH);
00000e  4c32              LDR      r4,|L11.216|
000010  210c              MOVS     r1,#0xc
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       PDMA_Open
;;;73     
;;;74     	//RX
;;;75         PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000018  2310              MOVS     r3,#0x10
00001a  2200              MOVS     r2,#0
00001c  2103              MOVS     r1,#3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       PDMA_SetTransferCnt
;;;76         /* Set source/destination address and attributes */
;;;77         PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_RX_DMA_CH, (uint32_t)&QSPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8SlaveRxBuffer, PDMA_DAR_INC);
000024  2500              MOVS     r5,#0
000026  482d              LDR      r0,|L11.220|
000028  e9cd0500          STRD     r0,r5,[sp,#0]
00002c  f44f7340          MOV      r3,#0x300
000030  4a2b              LDR      r2,|L11.224|
000032  2103              MOVS     r1,#3
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       PDMA_SetTransferAddr
;;;78         /* Set request source; set basic mode. */
;;;79         PDMA_SetTransferMode(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00003a  2300              MOVS     r3,#0
00003c  2215              MOVS     r2,#0x15
00003e  2103              MOVS     r1,#3
000040  4620              MOV      r0,r4
000042  9500              STR      r5,[sp,#0]
000044  f7fffffe          BL       PDMA_SetTransferMode
;;;80         /* Single request type. SPI only support PDMA single request type. */
;;;81         PDMA_SetBurstType(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000048  2300              MOVS     r3,#0
00004a  2204              MOVS     r2,#4
00004c  2103              MOVS     r1,#3
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       PDMA_SetBurstType
;;;82         /* Disable table interrupt */
;;;83         PDMA->DSCT[QSPI_SLAVE_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000054  6b20              LDR      r0,[r4,#0x30]
000056  f0400080          ORR      r0,r0,#0x80
00005a  6320              STR      r0,[r4,#0x30]
;;;84     
;;;85     	//TX
;;;86         PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
00005c  2310              MOVS     r3,#0x10
00005e  2200              MOVS     r2,#0
000060  2102              MOVS     r1,#2
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       PDMA_SetTransferCnt
;;;87         /* Set source/destination address and attributes */
;;;88         PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_TX_DMA_CH, (uint32_t)g_au8SlaveToMasterTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);
000068  481d              LDR      r0,|L11.224|
00006a  f44f6140          MOV      r1,#0xc00
00006e  3810              SUBS     r0,r0,#0x10
000070  4a1a              LDR      r2,|L11.220|
000072  e9cd0100          STRD     r0,r1,[sp,#0]
000076  2300              MOVS     r3,#0
000078  3a20              SUBS     r2,r2,#0x20
00007a  2102              MOVS     r1,#2
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       PDMA_SetTransferAddr
;;;89         /* Set request source; set basic mode. */
;;;90         PDMA_SetTransferMode(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
000082  2300              MOVS     r3,#0
000084  2214              MOVS     r2,#0x14
000086  2102              MOVS     r1,#2
000088  4620              MOV      r0,r4
00008a  9500              STR      r5,[sp,#0]
00008c  f7fffffe          BL       PDMA_SetTransferMode
;;;91         /* Single request type. SPI only support PDMA single request type. */
;;;92         PDMA_SetBurstType(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000090  2300              MOVS     r3,#0
000092  2204              MOVS     r2,#4
000094  2102              MOVS     r1,#2
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       PDMA_SetBurstType
;;;93         /* Disable table interrupt */
;;;94         PDMA->DSCT[QSPI_SLAVE_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00009c  6a20              LDR      r0,[r4,#0x20]
00009e  f0400080          ORR      r0,r0,#0x80
0000a2  6220              STR      r0,[r4,#0x20]
;;;95     
;;;96         QSPI_TRIGGER_RX_PDMA(QSPI0);
0000a4  480e              LDR      r0,|L11.224|
0000a6  3830              SUBS     r0,r0,#0x30
0000a8  68c1              LDR      r1,[r0,#0xc]
0000aa  f0410102          ORR      r1,r1,#2
0000ae  60c1              STR      r1,[r0,#0xc]
;;;97         QSPI_TRIGGER_TX_PDMA(QSPI0);
0000b0  68c1              LDR      r1,[r0,#0xc]
0000b2  f0410101          ORR      r1,r1,#1
0000b6  60c1              STR      r1,[r0,#0xc]
;;;98     
;;;99         PDMA_EnableInt(PDMA, QSPI_SLAVE_TX_DMA_CH, PDMA_INT_TRANS_DONE);
0000b8  2200              MOVS     r2,#0
0000ba  2102              MOVS     r1,#2
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       PDMA_EnableInt
;;;100        PDMA_EnableInt(PDMA, QSPI_SLAVE_RX_DMA_CH, PDMA_INT_TRANS_DONE);
0000c2  2200              MOVS     r2,#0
0000c4  2103              MOVS     r1,#3
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       PDMA_EnableInt
;;;101        NVIC_EnableIRQ(PDMA_IRQn);	
0000cc  e8bd407c          POP      {r2-r6,lr}
0000d0  2028              MOVS     r0,#0x28
0000d2  f7ffbffe          B.W      NVIC_EnableIRQ
;;;102    	
;;;103    }
;;;104    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L11.216|
                          DCD      0x40008000
                  |L11.220|
                          DCD      ||.bss||+0x30
                  |L11.224|
                          DCD      0x40060030

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;479    
;;;480    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L12.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L12.10|
;;;481    {
;;;482        /*---------------------------------------------------------------------------------------------------------*/
;;;483        /* Init System Clock                                                                                       */
;;;484        /*---------------------------------------------------------------------------------------------------------*/
;;;485        /* Unlock protected registers */
;;;486        SYS_UnlockReg();
;;;487    
;;;488        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;489        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;490    
;;;491        /* Enable External XTAL (4~24 MHz) */
;;;492        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;493    
;;;494        /* Waiting for 12MHz clock ready */
;;;495        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;496    
;;;497        /* Set core clock as PLL_CLOCK from PLL */
;;;498        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481c              LDR      r0,|L12.172|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;499        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;500        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;501    
;;;502        /* Enable UART clock */
;;;503        CLK_EnableModuleClock(UART0_MODULE);
000046  4e1a              LDR      r6,|L12.176|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;504    
;;;505        /* Select UART clock source from HXT */
;;;506        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;507    
;;;508        CLK_SetModuleClock(QSPI0_MODULE, CLK_CLKSEL2_QSPI0SEL_PCLK0, MODULE_NoMsk);
000058  4e16              LDR      r6,|L12.180|
00005a  2200              MOVS     r2,#0
00005c  2108              MOVS     r1,#8
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;509        CLK_EnableModuleClock(QSPI0_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;510    
;;;511        CLK_EnableModuleClock(PDMA_MODULE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       CLK_EnableModuleClock
;;;512    
;;;513    //	TIMER0_HW_Init();
;;;514    	TIMER1_HW_Init();
000070  f7fffffe          BL       TIMER1_HW_Init
;;;515    	
;;;516        /* Update System Core Clock */
;;;517        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;518        SystemCoreClockUpdate();
000074  f7fffffe          BL       SystemCoreClockUpdate
;;;519    
;;;520        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;521        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000078  6be0              LDR      r0,[r4,#0x3c]
00007a  f420007f          BIC      r0,r0,#0xff0000
00007e  63e0              STR      r0,[r4,#0x3c]
;;;522        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000080  6be0              LDR      r0,[r4,#0x3c]
000082  f44000cc          ORR      r0,r0,#0x660000
000086  63e0              STR      r0,[r4,#0x3c]
;;;523    
;;;524        /* Setup QSPI0 multi-function pins */
;;;525        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_QSPI0_MOSI0 | SYS_GPA_MFPL_PA1MFP_QSPI0_MISO0 | SYS_GPA_MFPL_PA2MFP_QSPI0_CLK | SYS_GPA_MFPL_PA3MFP_QSPI0_SS |
000088  6b20              LDR      r0,[r4,#0x30]
00008a  490b              LDR      r1,|L12.184|
00008c  4308              ORRS     r0,r0,r1
00008e  6320              STR      r0,[r4,#0x30]
;;;526                         SYS_GPA_MFPL_PA4MFP_QSPI0_MOSI1 | SYS_GPA_MFPL_PA5MFP_QSPI0_MISO1;
;;;527    
;;;528        /* Enable QSPI0 clock pin (PA2) schmitt trigger */
;;;529        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
000090  6a68              LDR      r0,[r5,#0x24]
000092  f0400004          ORR      r0,r0,#4
000096  6268              STR      r0,[r5,#0x24]
;;;530    
;;;531        /* Enable QSPI0 I/O high slew rate */
;;;532        GPIO_SetSlewCtl(PA, 0x3F, GPIO_SLEWCTL_HIGH);
000098  2201              MOVS     r2,#1
00009a  213f              MOVS     r1,#0x3f
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       GPIO_SetSlewCtl
0000a2  2000              MOVS     r0,#0
0000a4  f8c40100          STR      r0,[r4,#0x100]
;;;533    	
;;;534        /* Lock protected registers */
;;;535        SYS_LockReg();
;;;536    }
0000a8  bd70              POP      {r4-r6,pc}
;;;537    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L12.172|
                          DCD      0x0b71b000
                  |L12.176|
                          DCD      0x57803d10
                  |L12.180|
                          DCD      0x6620000c
                  |L12.184|
                          DCD      0x00333333

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;460    
;;;461    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;462    {
;;;463    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L13.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;464    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;465    }
;;;466    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;466    
;;;467    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;468    {
;;;469    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L14.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;470    }
;;;471    
                          ENDP

                  |L14.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;446    
;;;447    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;448    {
;;;449        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L15.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;450        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;451    }
;;;452    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;452    
;;;453    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;454    {
;;;455        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L16.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;456        TIMER_EnableInt(TIMER1);
;;;457        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;458        TIMER_Start(TIMER1);
;;;459    }
000028  bd10              POP      {r4,pc}
;;;460    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR1_IRQHandler PROC
;;;428    
;;;429    void TMR1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  480f              LDR      r0,|L17.64|
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
;;;430    {
00000a  2900              CMP      r1,#0
00000c  d016              BEQ      |L17.60|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;431    	static uint16_t CNT = 0;	
;;;432    	static uint32_t log = 0;	
;;;433    	
;;;434        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;435        {
;;;436            TIMER_ClearIntFlag(TIMER1);
;;;437    	
;;;438    		if (CNT++ > 1000)
000012  490c              LDR      r1,|L17.68|
000014  8848              LDRH     r0,[r1,#2]  ; CNT
000016  1c42              ADDS     r2,r0,#1
000018  804a              STRH     r2,[r1,#2]
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d90d              BLS      |L17.60|
;;;439    		{		
;;;440    			CNT = 0;
000020  2000              MOVS     r0,#0
000022  8048              STRH     r0,[r1,#2]
;;;441    			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
000024  684a              LDR      r2,[r1,#4]  ; log
000026  1c50              ADDS     r0,r2,#1
000028  6048              STR      r0,[r1,#4]  ; log
00002a  4907              LDR      r1,|L17.72|
00002c  a007              ADR      r0,|L17.76|
00002e  f7fffffe          BL       __2printf
;;;442    			LED_R ^= 1;
000032  4809              LDR      r0,|L17.88|
000034  6801              LDR      r1,[r0,#0]
000036  f0810101          EOR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L17.60|
;;;443    		}
;;;444        }
;;;445    }
00003c  bd10              POP      {r4,pc}
;;;446    
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      0x40050100
                  |L17.68|
                          DCD      ||.data||
                  |L17.72|
                          DCD      ||.constdata||
                  |L17.76|
00004c  2573203a          DCB      "%s : %2d\r\n",0
000050  20253264
000054  0d0a00  
000057  00                DCB      0
                  |L17.88|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;545    
;;;546    int main()
000000  f7fffffe          BL       SYS_Init
;;;547    {
;;;548    	
;;;549        SYS_Init();
;;;550        /* Init UART to 115200-8n1 for print message */
;;;551        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  4814              LDR      r0,|L18.92|
00000a  f7fffffe          BL       UART_Open
;;;552    
;;;553    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a012              ADR      r0,|L18.96|
000016  f7fffffe          BL       __2printf
;;;554    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a016              ADR      r0,|L18.124|
000022  f7fffffe          BL       __2printf
;;;555    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a019              ADR      r0,|L18.148|
00002e  f7fffffe          BL       __2printf
;;;556    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a01c              ADR      r0,|L18.172|
00003a  f7fffffe          BL       __2printf
;;;557    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a020              ADR      r0,|L18.200|
000046  f7fffffe          BL       __2printf
;;;558    
;;;559    	LED_Init();
00004a  f7fffffe          BL       LED_Init
;;;560    	TIMER1_Init();
00004e  f7fffffe          BL       TIMER1_Init
;;;561    
;;;562    	#if defined (ENABLE_QSPI_MASTER)
;;;563    	
;;;564    	QSPI_Master_Init();
000052  f7fffffe          BL       QSPI_Master_Init
;;;565    	QSPI_Master_PDMA_PreInit();
000056  f7fffffe          BL       QSPI_Master_PDMA_PreInit
                  |L18.90|
;;;566    	
;;;567    	#elif defined (ENABLE_QSPI_SLAVE)
;;;568    	
;;;569    	QSPI_Slave_Init();
;;;570    	QSPI_Slave_PDMA_PreInit();
;;;571    
;;;572    	#endif
;;;573    
;;;574        /* Got no where to go, just loop forever */
;;;575        while(1)
00005a  e7fe              B        |L18.90|
;;;576        {
;;;577    //		TIMER0_Polling(100);
;;;578    		
;;;579    
;;;580        }
;;;581    
;;;582    }
;;;583    
                          ENDP

                  |L18.92|
                          DCD      0x40070000
                  |L18.96|
000060  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000064  4b5f4765
000068  74435055
00006c  46726571
000070  203a2025
000074  38640d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L18.124|
00007c  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000080  47657448
000084  58544672
000088  6571203a
00008c  20253864
000090  0d0a00  
000093  00                DCB      0
                  |L18.148|
000094  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000098  4765744c
00009c  58544672
0000a0  6571203a
0000a4  20253864
0000a8  0d0a00  
0000ab  00                DCB      0
                  |L18.172|
0000ac  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b0  47657450
0000b4  434c4b30
0000b8  46726571
0000bc  203a2025
0000c0  38640d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L18.200|
0000c8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000cc  47657450
0000d0  434c4b31
0000d4  46726571
0000d8  203a2025
0000dc  38640d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8MasterToSlaveTestPattern
                          %        16
                  g_au8SlaveToMasterTestPattern
                          %        16
                  g_au8MasterRxBuffer
                          %        16
                  g_au8SlaveRxBuffer
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5231          DCB      0x54,0x4d,0x52,0x31
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  k
000000  1000              DCB      0x10,0x00
                  ||CNT||
000002  0000              DCW      0x0000
                  log
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_468c6c6b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REVSH|
#line 402
|__asm___6_main_c_468c6c6b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____RRX|
#line 587
|__asm___6_main_c_468c6c6b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
