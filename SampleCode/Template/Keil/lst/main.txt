; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_QSPI_MASTER --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;462    
;;;463    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;466    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;467    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;468    	
;;;469    }
;;;470    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;319    
;;;320    void PDMA_IRQHandler(void)
000000  491b              LDR      r1,|L3.112|
;;;321    {
000002  b510              PUSH     {r4,lr}
;;;322    	#if defined (ENABLE_QSPI_MASTER)	
;;;323        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000004  6808              LDR      r0,[r1,#0]
;;;324    	
;;;325        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000006  07c2              LSLS     r2,r0,#31
000008  d003              BEQ      |L3.18|
;;;326        {
;;;327    		#if 1
;;;328            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
00000a  1d08              ADDS     r0,r1,#4
00000c  6801              LDR      r1,[r0,#0]
00000e  6001              STR      r1,[r0,#0]
                  |L3.16|
;;;329    		#else
;;;330            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_MASTER_TX_DMA_CH))
;;;331            {
;;;332    
;;;333            }
;;;334            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_MASTER_TX_DMA_CH));
;;;335    
;;;336            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_MASTER_RX_DMA_CH))
;;;337            {
;;;338    
;;;339            }
;;;340            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_MASTER_RX_DMA_CH));
;;;341    		#endif
;;;342        }
;;;343        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;344        {
;;;345            if((PDMA_GET_TD_STS(PDMA) & QSPI_MASTER_OPENED_CH) == QSPI_MASTER_OPENED_CH)
;;;346            {
;;;347                /* Clear PDMA transfer done interrupt flag */
;;;348                PDMA_CLR_TD_FLAG(PDMA, QSPI_MASTER_OPENED_CH);
;;;349    
;;;350    			//insert process
;;;351    			QSPI_DISABLE_TX_PDMA(QSPI0);
;;;352    			QSPI_DISABLE_RX_PDMA(QSPI0);
;;;353    			LED_Y ^= 1;
;;;354    			QSPI_Master_PDMA_Enable(QSPI_TX);
;;;355    			QSPI_Master_PDMA_Enable(QSPI_RX);
;;;356            }        		
;;;357        }
;;;358        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;359        {
;;;360    		LED_G ^= 1;
;;;361            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_MASTER_TX_DMA_CH);
;;;362            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_MASTER_RX_DMA_CH);
;;;363        }
;;;364        else
;;;365        {
;;;366    
;;;367        }
;;;368    
;;;369    	#elif defined (ENABLE_QSPI_SLAVE)
;;;370        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
;;;371    	
;;;372        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
;;;373        {
;;;374    		#if 1
;;;375            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
;;;376    		#else
;;;377            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_SLAVE_TX_DMA_CH))
;;;378            {
;;;379    
;;;380            }
;;;381            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_SLAVE_TX_DMA_CH));
;;;382    
;;;383            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_SLAVE_RX_DMA_CH))
;;;384            {
;;;385    
;;;386            }
;;;387            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_SLAVE_RX_DMA_CH));
;;;388    		#endif
;;;389        }
;;;390        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;391        {
;;;392            if((PDMA_GET_TD_STS(PDMA) & QSPI_SLAVE_OPENED_CH) == QSPI_SLAVE_OPENED_CH)
;;;393            {
;;;394                /* Clear PDMA transfer done interrupt flag */
;;;395                PDMA_CLR_TD_FLAG(PDMA, QSPI_SLAVE_OPENED_CH);
;;;396    
;;;397    			//insert process
;;;398    			QSPI_DISABLE_TX_PDMA(QSPI0);
;;;399    			QSPI_DISABLE_RX_PDMA(QSPI0);			
;;;400    			LED_Y ^= 1;
;;;401    			QSPI_Slave_PDMA_Enable(QSPI_TX);
;;;402    			QSPI_Slave_PDMA_Enable(QSPI_RX);			
;;;403            }        		
;;;404        }
;;;405        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;406        {
;;;407    		LED_G ^= 1;
;;;408            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_SLAVE_TX_DMA_CH);
;;;409            PDMA_CLR_TMOUT_FLAG(PDMA,QSPI_SLAVE_RX_DMA_CH);
;;;410        }
;;;411        else
;;;412        {
;;;413    
;;;414        }
;;;415    
;;;416    	#endif
;;;417    	
;;;418    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  0782              LSLS     r2,r0,#30             ;343
000014  d51d              BPL      |L3.82|
000016  4816              LDR      r0,|L3.112|
000018  3008              ADDS     r0,r0,#8              ;345
00001a  6801              LDR      r1,[r0,#0]            ;345
00001c  43c9              MVNS     r1,r1                 ;345
00001e  0789              LSLS     r1,r1,#30             ;345
000020  d1f6              BNE      |L3.16|
000022  2103              MOVS     r1,#3                 ;348
000024  6001              STR      r1,[r0,#0]            ;348
000026  4813              LDR      r0,|L3.116|
000028  68c1              LDR      r1,[r0,#0xc]          ;351
00002a  f0210101          BIC      r1,r1,#1              ;351
00002e  60c1              STR      r1,[r0,#0xc]          ;351
000030  68c1              LDR      r1,[r0,#0xc]          ;352
000032  f0210102          BIC      r1,r1,#2              ;352
000036  60c1              STR      r1,[r0,#0xc]          ;352
000038  480f              LDR      r0,|L3.120|
00003a  6801              LDR      r1,[r0,#0]            ;353
00003c  f0810101          EOR      r1,r1,#1              ;353
000040  6001              STR      r1,[r0,#0]            ;353
000042  2000              MOVS     r0,#0                 ;354
000044  f7fffffe          BL       QSPI_Master_PDMA_Enable
000048  e8bd4010          POP      {r4,lr}               ;355
00004c  2001              MOVS     r0,#1                 ;355
00004e  f7ffbffe          B.W      QSPI_Master_PDMA_Enable
                  |L3.82|
000052  f4107f40          TST      r0,#0x300             ;358
000056  d0db              BEQ      |L3.16|
000058  4807              LDR      r0,|L3.120|
00005a  1d00              ADDS     r0,r0,#4              ;360
00005c  6802              LDR      r2,[r0,#0]            ;360
00005e  f0820201          EOR      r2,r2,#1              ;360
000062  6002              STR      r2,[r0,#0]            ;360
000064  1580              ASRS     r0,r0,#22             ;361
000066  6008              STR      r0,[r1,#0]            ;361
000068  0040              LSLS     r0,r0,#1              ;362
00006a  6008              STR      r0,[r1,#0]            ;362
00006c  bd10              POP      {r4,pc}
;;;419    
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0x4000841c
                  |L3.116|
                          DCD      0x40060000
                  |L3.120|
                          DCD      0x400049c4

                          AREA ||i.QSPI_Master_Init||, CODE, READONLY, ALIGN=2

                  QSPI_Master_Init PROC
;;;310    */
;;;311    void QSPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;312    {
;;;313        QSPI_Open(QSPI0, QSPI_MASTER, QSPI_MODE_0, 8, QSPI_TARGET_FREQ);
000002  4808              LDR      r0,|L4.36|
000004  4c08              LDR      r4,|L4.40|
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       QSPI_Open
;;;314    
;;;315        /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;316        QSPI_EnableAutoSS(QSPI0, QSPI_SS, QSPI_SS_ACTIVE_LOW);
000014  4620              MOV      r0,r4
000016  e8bd4038          POP      {r3-r5,lr}
00001a  2200              MOVS     r2,#0
00001c  2101              MOVS     r1,#1
00001e  f7ffbffe          B.W      QSPI_EnableAutoSS
;;;317    }
;;;318    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x000f4240
                  |L4.40|
                          DCD      0x40060000

                          AREA ||i.QSPI_Master_PDMA_ClrBuffer||, CODE, READONLY, ALIGN=2

                  QSPI_Master_PDMA_ClrBuffer PROC
;;;176    
;;;177    void QSPI_Master_PDMA_ClrBuffer(uint8_t TxRx)
000000  2100              MOVS     r1,#0
;;;178    {
;;;179        uint16_t i = 0;
;;;180    
;;;181    	if (TxRx == QSPI_TX)
;;;182    	{
;;;183    	    for (i = 0; i < DATA_NUM; i++)
;;;184    	    {
;;;185    	        g_au8MasterToSlaveTestPattern[i] = 0xFF;
000002  22ff              MOVS     r2,#0xff
000004  b130              CBZ      r0,|L5.20|
;;;186    	    }
;;;187    	}
;;;188    	else
;;;189    	{
;;;190    	    for (i = 0; i < DATA_NUM; i++)
;;;191    	    {
;;;192    	        g_au8MasterRxBuffer[i] = 0xFF;
000006  4807              LDR      r0,|L5.36|
                  |L5.8|
000008  5442              STRB     r2,[r0,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  b289              UXTH     r1,r1                 ;190
00000e  2910              CMP      r1,#0x10              ;190
000010  d3fa              BCC      |L5.8|
;;;193    	    }
;;;194    	}
;;;195    }
000012  4770              BX       lr
                  |L5.20|
000014  4803              LDR      r0,|L5.36|
000016  3820              SUBS     r0,r0,#0x20           ;185
                  |L5.24|
000018  5442              STRB     r2,[r0,r1]            ;185
00001a  1c49              ADDS     r1,r1,#1              ;185
00001c  b289              UXTH     r1,r1                 ;183
00001e  2910              CMP      r1,#0x10              ;183
000020  d3fa              BCC      |L5.24|
000022  4770              BX       lr
;;;196    
                          ENDP

                  |L5.36|
                          DCD      ||.bss||+0x20

                          AREA ||i.QSPI_Master_PDMA_Enable||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  QSPI_Master_PDMA_Enable PROC
;;;240    
;;;241    void QSPI_Master_PDMA_Enable(uint8_t TxRx)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;242    {
;;;243        uint16_t i = 0;
000004  2400              MOVS     r4,#0
;;;244        static uint16_t j = 0;
;;;245    	
;;;246    	if (TxRx == QSPI_TX)
;;;247    	{
;;;248    		QSPI_Master_PDMA_ClrBuffer(QSPI_TX);
;;;249    	
;;;250    		//prepare master TX data
;;;251    		g_au8MasterToSlaveTestPattern[INDEX_HEAD] = DATA_HEAD_MASTER;
;;;252    		g_au8MasterToSlaveTestPattern[INDEX_TAIL] = DATA_TAIL_MASTER;
;;;253    
;;;254    		j = 1;
;;;255    	    for (i = (INDEX_HEAD+1); i < INDEX_TAIL ; i++)
;;;256    	    {
;;;257    	        g_au8MasterToSlaveTestPattern[i] = (i + 0x10*(j++));
;;;258    	    }
;;;259    		j = 0;
;;;260    
;;;261    		#if 1	//TX debug
;;;262    		printf("\r\ng_au8MasterToSlaveTestPattern : \r\n");
;;;263    		for (i = 0 ; i < DATA_NUM ; i++)
;;;264    		{
;;;265    			printf("0x%2X," , g_au8MasterToSlaveTestPattern[i]);
;;;266                if ((i+1)%8 ==0)
;;;267                {
;;;268                    printf("\r\n");
;;;269                }			
;;;270    		}
;;;271    		#endif
;;;272    	
;;;273    		//TX
;;;274    	    PDMA_SetTransferCnt(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000006  4e3d              LDR      r6,|L6.252|
;;;275    		PDMA_SetTransferAddr(PDMA,QSPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);		
;;;276    	    /* Set request source; set basic mode. */
;;;277    	    PDMA_SetTransferMode(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
;;;278    	    QSPI_TRIGGER_TX_PDMA(QSPI0);	
000008  4d3d              LDR      r5,|L6.256|
00000a  4627              MOV      r7,r4
00000c  2301              MOVS     r3,#1                 ;254
00000e  b1e8              CBZ      r0,|L6.76|
;;;279    	}
;;;280    	else
;;;281    	{
;;;282    		//RX	
;;;283    		PDMA_SetTransferCnt(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000010  2310              MOVS     r3,#0x10
000012  2200              MOVS     r2,#0
000014  2101              MOVS     r1,#1
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;284    		/* Set request source; set basic mode. */
;;;285    		PDMA_SetTransferMode(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00001c  2300              MOVS     r3,#0
00001e  2215              MOVS     r2,#0x15
000020  2101              MOVS     r1,#1
000022  4630              MOV      r0,r6
000024  9700              STR      r7,[sp,#0]
000026  f7fffffe          BL       PDMA_SetTransferMode
;;;286    		QSPI_TRIGGER_RX_PDMA(QSPI0);
00002a  68e8              LDR      r0,[r5,#0xc]
00002c  f0400002          ORR      r0,r0,#2
000030  60e8              STR      r0,[r5,#0xc]
;;;287    
;;;288    		#if 1	//RX debug
;;;289    		printf("\r\ng_au8MasterRxBuffer : \r\n");
000032  a034              ADR      r0,|L6.260|
000034  f7fffffe          BL       __2printf
;;;290    		for (i = 0 ; i < DATA_NUM ; i++)
;;;291    		{
;;;292    			printf("0x%2X," , g_au8MasterRxBuffer[i]);
000038  4d39              LDR      r5,|L6.288|
                  |L6.58|
00003a  a03a              ADR      r0,|L6.292|
00003c  5d29              LDRB     r1,[r5,r4]
00003e  f7fffffe          BL       __2printf
;;;293                if ((i+1)%8 ==0)
000042  0760              LSLS     r0,r4,#29
000044  f1b04f60          CMP      r0,#0xe0000000
000048  d04c              BEQ      |L6.228|
00004a  e04e              B        |L6.234|
                  |L6.76|
00004c  2000              MOVS     r0,#0                 ;248
00004e  f7fffffe          BL       QSPI_Master_PDMA_ClrBuffer
000052  4c33              LDR      r4,|L6.288|
000054  2030              MOVS     r0,#0x30              ;251
000056  3c20              SUBS     r4,r4,#0x20           ;251
000058  4a34              LDR      r2,|L6.300|
00005a  7020              STRB     r0,[r4,#0]            ;251
00005c  2036              MOVS     r0,#0x36              ;252
00005e  73e0              STRB     r0,[r4,#0xf]          ;252
000060  8013              STRH     r3,[r2,#0]            ;254
000062  2001              MOVS     r0,#1                 ;255
                  |L6.100|
000064  8811              LDRH     r1,[r2,#0]            ;257  ; j
000066  eb001301          ADD      r3,r0,r1,LSL #4       ;257
00006a  5423              STRB     r3,[r4,r0]            ;257
00006c  1c49              ADDS     r1,r1,#1              ;257
00006e  1c40              ADDS     r0,r0,#1              ;257
000070  b280              UXTH     r0,r0                 ;255
000072  8011              STRH     r1,[r2,#0]            ;257
000074  280f              CMP      r0,#0xf               ;255
000076  d3f5              BCC      |L6.100|
000078  46b8              MOV      r8,r7                 ;259
00007a  8017              STRH     r7,[r2,#0]            ;259
00007c  a02c              ADR      r0,|L6.304|
00007e  f7fffffe          BL       __2printf
000082  2700              MOVS     r7,#0                 ;263
                  |L6.132|
000084  a027              ADR      r0,|L6.292|
000086  5de1              LDRB     r1,[r4,r7]            ;265
000088  f7fffffe          BL       __2printf
00008c  0778              LSLS     r0,r7,#29             ;266
00008e  f1b04f60          CMP      r0,#0xe0000000        ;266
000092  d102              BNE      |L6.154|
000094  a021              ADR      r0,|L6.284|
000096  f7fffffe          BL       __2printf
                  |L6.154|
00009a  1c7f              ADDS     r7,r7,#1              ;268
00009c  b2bf              UXTH     r7,r7                 ;263
00009e  2f10              CMP      r7,#0x10              ;263
0000a0  d3f0              BCC      |L6.132|
0000a2  2200              MOVS     r2,#0                 ;274
0000a4  2310              MOVS     r3,#0x10              ;274
0000a6  4611              MOV      r1,r2                 ;274
0000a8  4630              MOV      r0,r6                 ;274
0000aa  f7fffffe          BL       PDMA_SetTransferCnt
0000ae  4814              LDR      r0,|L6.256|
0000b0  f44f6140          MOV      r1,#0xc00             ;275
0000b4  3020              ADDS     r0,r0,#0x20           ;275
0000b6  4a1a              LDR      r2,|L6.288|
0000b8  e9cd0100          STRD     r0,r1,[sp,#0]         ;275
0000bc  2300              MOVS     r3,#0                 ;275
0000be  3a20              SUBS     r2,r2,#0x20           ;275
0000c0  4619              MOV      r1,r3                 ;275
0000c2  4630              MOV      r0,r6                 ;275
0000c4  f7fffffe          BL       PDMA_SetTransferAddr
0000c8  2300              MOVS     r3,#0                 ;277
0000ca  2214              MOVS     r2,#0x14              ;277
0000cc  4619              MOV      r1,r3                 ;277
0000ce  4630              MOV      r0,r6                 ;277
0000d0  f8cd8000          STR      r8,[sp,#0]            ;277
0000d4  f7fffffe          BL       PDMA_SetTransferMode
0000d8  68e8              LDR      r0,[r5,#0xc]          ;278
0000da  f0400001          ORR      r0,r0,#1              ;278
0000de  60e8              STR      r0,[r5,#0xc]          ;278
;;;294                {
;;;295                    printf("\r\n");
;;;296                }			
;;;297    		}
;;;298    		#endif
;;;299    
;;;300    		QSPI_Master_PDMA_ClrBuffer(QSPI_RX);			
;;;301    	}
;;;302    }
0000e0  e8bd81fc          POP      {r2-r8,pc}
                  |L6.228|
0000e4  a00d              ADR      r0,|L6.284|
0000e6  f7fffffe          BL       __2printf
                  |L6.234|
0000ea  1c64              ADDS     r4,r4,#1              ;295
0000ec  b2a4              UXTH     r4,r4                 ;290
0000ee  2c10              CMP      r4,#0x10              ;290
0000f0  d3a3              BCC      |L6.58|
0000f2  e8bd41fc          POP      {r2-r8,lr}            ;300
0000f6  2001              MOVS     r0,#1                 ;300
0000f8  f7ffbffe          B.W      QSPI_Master_PDMA_ClrBuffer
;;;303    
                          ENDP

                  |L6.252|
                          DCD      0x40008000
                  |L6.256|
                          DCD      0x40060000
                  |L6.260|
000104  0d0a675f          DCB      "\r\ng_au8MasterRxBuffer : "
000108  6175384d
00010c  61737465
000110  72527842
000114  75666665
000118  72203a20
                  |L6.284|
00011c  0d0a00            DCB      "\r\n",0
00011f  00                DCB      0
                  |L6.288|
                          DCD      ||.bss||+0x20
                  |L6.292|
000124  30782532          DCB      "0x%2X,",0
000128  582c00  
00012b  00                DCB      0
                  |L6.300|
                          DCD      ||.data||
                  |L6.304|
000130  0d0a675f          DCB      "\r\ng_au8MasterToSlaveTestPattern : \r\n",0
000134  6175384d
000138  61737465
00013c  72546f53
000140  6c617665
000144  54657374
000148  50617474
00014c  65726e20
000150  3a200d0a
000154  00      
000155  00                DCB      0
000156  00                DCB      0
000157  00                DCB      0

                          AREA ||i.QSPI_Master_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  QSPI_Master_PDMA_PreInit PROC
;;;196    
;;;197    void QSPI_Master_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;198    {
;;;199        uint16_t i = 0;
;;;200    	
;;;201    	//prepare data
;;;202        for (i=0; i < DATA_NUM; i++)
;;;203        {
;;;204            g_au8MasterToSlaveTestPattern[i] = i;
000002  4a36              LDR      r2,|L7.220|
000004  2000              MOVS     r0,#0                 ;199
;;;205            g_au8MasterRxBuffer[i] = 0xFF;
000006  21ff              MOVS     r1,#0xff
000008  f1020420          ADD      r4,r2,#0x20
                  |L7.12|
00000c  5410              STRB     r0,[r2,r0]            ;204
00000e  5421              STRB     r1,[r4,r0]
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0                 ;202
000014  2810              CMP      r0,#0x10              ;202
000016  d3f9              BCC      |L7.12|
;;;206        }
;;;207    
;;;208        PDMA_Open(PDMA, QSPI_MASTER_OPENED_CH);
000018  4d31              LDR      r5,|L7.224|
00001a  2103              MOVS     r1,#3
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       PDMA_Open
;;;209    
;;;210    	//TX
;;;211        PDMA_SetTransferCnt(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000022  2200              MOVS     r2,#0
000024  2310              MOVS     r3,#0x10
000026  4611              MOV      r1,r2
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferCnt
;;;212        /* Set source/destination address and attributes */
;;;213        PDMA_SetTransferAddr(PDMA,QSPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);
00002e  f44f6140          MOV      r1,#0xc00
000032  482c              LDR      r0,|L7.228|
000034  e9cd0100          STRD     r0,r1,[sp,#0]
000038  2300              MOVS     r3,#0
00003a  4a28              LDR      r2,|L7.220|
00003c  4619              MOV      r1,r3
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       PDMA_SetTransferAddr
;;;214        /* Set request source; set basic mode. */
;;;215        PDMA_SetTransferMode(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
000044  2600              MOVS     r6,#0
000046  4633              MOV      r3,r6
000048  2214              MOVS     r2,#0x14
00004a  4631              MOV      r1,r6
00004c  4628              MOV      r0,r5
00004e  9600              STR      r6,[sp,#0]
000050  f7fffffe          BL       PDMA_SetTransferMode
;;;216        /* Single request type. SPI only support PDMA single request type. */
;;;217        PDMA_SetBurstType(PDMA,QSPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000054  2300              MOVS     r3,#0
000056  2204              MOVS     r2,#4
000058  4619              MOV      r1,r3
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       PDMA_SetBurstType
;;;218        /* Disable table interrupt */
;;;219        PDMA->DSCT[QSPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000060  6828              LDR      r0,[r5,#0]
000062  f0400080          ORR      r0,r0,#0x80
000066  6028              STR      r0,[r5,#0]
;;;220    
;;;221    	//RX	
;;;222        PDMA_SetTransferCnt(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000068  2310              MOVS     r3,#0x10
00006a  2200              MOVS     r2,#0
00006c  2101              MOVS     r1,#1
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       PDMA_SetTransferCnt
;;;223        /* Set source/destination address and attributes */
;;;224        PDMA_SetTransferAddr(PDMA,QSPI_MASTER_RX_DMA_CH, (uint32_t)&QSPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8MasterRxBuffer, PDMA_DAR_INC);
000074  4a1b              LDR      r2,|L7.228|
000076  e9cd4600          STRD     r4,r6,[sp,#0]
00007a  f44f7340          MOV      r3,#0x300
00007e  3210              ADDS     r2,r2,#0x10
000080  2101              MOVS     r1,#1
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       PDMA_SetTransferAddr
;;;225        /* Set request source; set basic mode. */
;;;226        PDMA_SetTransferMode(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
000088  2300              MOVS     r3,#0
00008a  2215              MOVS     r2,#0x15
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  9600              STR      r6,[sp,#0]
000092  f7fffffe          BL       PDMA_SetTransferMode
;;;227        /* Single request type. SPI only support PDMA single request type. */
;;;228        PDMA_SetBurstType(PDMA,QSPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000096  2300              MOVS     r3,#0
000098  2204              MOVS     r2,#4
00009a  2101              MOVS     r1,#1
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       PDMA_SetBurstType
;;;229        /* Disable table interrupt */
;;;230        PDMA->DSCT[QSPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
0000a2  6928              LDR      r0,[r5,#0x10]
0000a4  f0400080          ORR      r0,r0,#0x80
0000a8  6128              STR      r0,[r5,#0x10]
;;;231    
;;;232        QSPI_TRIGGER_RX_PDMA(QSPI0);
0000aa  480e              LDR      r0,|L7.228|
0000ac  3820              SUBS     r0,r0,#0x20
0000ae  68c1              LDR      r1,[r0,#0xc]
0000b0  f0410102          ORR      r1,r1,#2
0000b4  60c1              STR      r1,[r0,#0xc]
;;;233        QSPI_TRIGGER_TX_PDMA(QSPI0);
0000b6  68c1              LDR      r1,[r0,#0xc]
0000b8  f0410101          ORR      r1,r1,#1
0000bc  60c1              STR      r1,[r0,#0xc]
;;;234    
;;;235        PDMA_EnableInt(PDMA, QSPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);
0000be  2200              MOVS     r2,#0
0000c0  4611              MOV      r1,r2
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       PDMA_EnableInt
;;;236        PDMA_EnableInt(PDMA, QSPI_MASTER_RX_DMA_CH, PDMA_INT_TRANS_DONE);
0000c8  2200              MOVS     r2,#0
0000ca  2101              MOVS     r1,#1
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       PDMA_EnableInt
;;;237        NVIC_EnableIRQ(PDMA_IRQn);
0000d2  e8bd407c          POP      {r2-r6,lr}
0000d6  2028              MOVS     r0,#0x28
0000d8  f7ffbffe          B.W      NVIC_EnableIRQ
;;;238    	
;;;239    }
;;;240    
                          ENDP

                  |L7.220|
                          DCD      ||.bss||
                  |L7.224|
                          DCD      0x40008000
                  |L7.228|
                          DCD      0x40060020

                          AREA ||i.QSPI_Slave_Init||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_Init PROC
;;;170    
;;;171    void QSPI_Slave_Init(void)
000000  b508              PUSH     {r3,lr}
;;;172    {
;;;173        QSPI_Open(QSPI0, QSPI_SLAVE, QSPI_MODE_0, 8, (uint32_t)NULL);
000002  2000              MOVS     r0,#0
000004  2204              MOVS     r2,#4
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  0411              LSLS     r1,r2,#16
00000c  4801              LDR      r0,|L8.20|
00000e  f7fffffe          BL       QSPI_Open
;;;174    }
000012  bd08              POP      {r3,pc}
;;;175    
                          ENDP

                  |L8.20|
                          DCD      0x40060000

                          AREA ||i.QSPI_Slave_PDMA_ClrBuffer||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_PDMA_ClrBuffer PROC
;;;46     
;;;47     void QSPI_Slave_PDMA_ClrBuffer(uint8_t TxRx)
000000  2100              MOVS     r1,#0
;;;48     {
;;;49         uint16_t i = 0;
;;;50     
;;;51     	if (TxRx == QSPI_TX)
;;;52     	{
;;;53     	    for (i = 0; i < DATA_NUM; i++)
;;;54     	    {
;;;55     	        g_au8SlaveToMasterTestPattern[i] = 0xFF;
000002  22ff              MOVS     r2,#0xff
000004  b130              CBZ      r0,|L9.20|
;;;56     	    }
;;;57     	}
;;;58     	else
;;;59     	{
;;;60     	    for (i = 0; i < DATA_NUM; i++)
;;;61     	    {
;;;62     	        g_au8SlaveRxBuffer[i] = 0xFF;
000006  4807              LDR      r0,|L9.36|
                  |L9.8|
000008  5442              STRB     r2,[r0,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  b289              UXTH     r1,r1                 ;60
00000e  2910              CMP      r1,#0x10              ;60
000010  d3fa              BCC      |L9.8|
;;;63     	    }
;;;64     	}
;;;65     }
000012  4770              BX       lr
                  |L9.20|
000014  4803              LDR      r0,|L9.36|
000016  3820              SUBS     r0,r0,#0x20           ;55
                  |L9.24|
000018  5442              STRB     r2,[r0,r1]            ;55
00001a  1c49              ADDS     r1,r1,#1              ;55
00001c  b289              UXTH     r1,r1                 ;53
00001e  2910              CMP      r1,#0x10              ;53
000020  d3fa              BCC      |L9.24|
000022  4770              BX       lr
;;;66     
                          ENDP

                  |L9.36|
                          DCD      ||.bss||+0x30

                          AREA ||i.QSPI_Slave_PDMA_Enable||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  QSPI_Slave_PDMA_Enable PROC
;;;104    
;;;105    void QSPI_Slave_PDMA_Enable(uint8_t TxRx)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;106    {
;;;107        uint16_t i = 0;
000004  2400              MOVS     r4,#0
;;;108    
;;;109    	if (TxRx == QSPI_TX)
;;;110    	{		
;;;111    		QSPI_Slave_PDMA_ClrBuffer(QSPI_TX);		
;;;112    
;;;113    		//prepare slave TX data
;;;114    		if ((g_au8SlaveRxBuffer[INDEX_HEAD] == DATA_HEAD_MASTER)&& 
;;;115    			(g_au8SlaveRxBuffer[INDEX_TAIL] == DATA_TAIL_MASTER))
;;;116    		{
;;;117    
;;;118    			g_au8SlaveToMasterTestPattern[INDEX_HEAD] = DATA_HEAD_SLAVE;
;;;119    			g_au8SlaveToMasterTestPattern[INDEX_TAIL] = DATA_TAIL_SLAVE;
;;;120    		
;;;121    		    for (i = (INDEX_HEAD+1); i < INDEX_TAIL; i++)
;;;122    		    {
;;;123    		        g_au8SlaveToMasterTestPattern[i] = i;
;;;124    		    }
;;;125    		}
;;;126    
;;;127    		#if 1	//TX debug
;;;128    		printf("\r\ng_au8SlaveToMasterTestPattern : \r\n");
;;;129    		for (i = 0 ; i < DATA_NUM ; i++)
;;;130    		{
;;;131    			printf("0x%2X," , g_au8SlaveToMasterTestPattern[i]);
;;;132                if ((i+1)%8 ==0)
;;;133                {
;;;134                    printf("\r\n");
;;;135                }			
;;;136    		}
;;;137    		#endif			
;;;138    	
;;;139    		//TX
;;;140    	    PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000006  4e3c              LDR      r6,|L10.248|
;;;141       	 	PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_TX_DMA_CH, (uint32_t)g_au8SlaveToMasterTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);		
;;;142    	    /* Set request source; set basic mode. */
;;;143    	    PDMA_SetTransferMode(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
;;;144    	    QSPI_TRIGGER_TX_PDMA(QSPI0);		
000008  4d3c              LDR      r5,|L10.252|
00000a  4f3d              LDR      r7,|L10.256|
00000c  46a0              MOV      r8,r4                 ;107
00000e  b1e8              CBZ      r0,|L10.76|
;;;145    
;;;146    	}
;;;147    	else
;;;148    	{		
;;;149    		//RX
;;;150    	    PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000010  2310              MOVS     r3,#0x10
000012  2200              MOVS     r2,#0
000014  2103              MOVS     r1,#3
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;151    	    /* Set request source; set basic mode. */
;;;152    	    PDMA_SetTransferMode(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00001c  2300              MOVS     r3,#0
00001e  2215              MOVS     r2,#0x15
000020  2103              MOVS     r1,#3
000022  4630              MOV      r0,r6
000024  f8cd8000          STR      r8,[sp,#0]
000028  f7fffffe          BL       PDMA_SetTransferMode
;;;153    	    QSPI_TRIGGER_RX_PDMA(QSPI0);	
00002c  68e8              LDR      r0,[r5,#0xc]
00002e  f0400002          ORR      r0,r0,#2
000032  60e8              STR      r0,[r5,#0xc]
;;;154    
;;;155    		#if 1	//RX debug
;;;156    		printf("\r\ng_au8SlaveRxBuffer : \r\n");
000034  a033              ADR      r0,|L10.260|
000036  f7fffffe          BL       __2printf
                  |L10.58|
;;;157    		for (i = 0 ; i < DATA_NUM ; i++)
;;;158    		{
;;;159    			printf("0x%2X," , g_au8SlaveRxBuffer[i]);
00003a  5d39              LDRB     r1,[r7,r4]
00003c  a038              ADR      r0,|L10.288|
00003e  f7fffffe          BL       __2printf
;;;160                if ((i+1)%8 ==0)
000042  0760              LSLS     r0,r4,#29
000044  f1b04f60          CMP      r0,#0xe0000000
000048  d049              BEQ      |L10.222|
00004a  e04b              B        |L10.228|
                  |L10.76|
00004c  2000              MOVS     r0,#0                 ;111
00004e  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
000052  4c2b              LDR      r4,|L10.256|
000054  7838              LDRB     r0,[r7,#0]            ;114  ; g_au8SlaveRxBuffer
000056  3c20              SUBS     r4,r4,#0x20           ;118
000058  2830              CMP      r0,#0x30              ;114
00005a  d10c              BNE      |L10.118|
00005c  7bf8              LDRB     r0,[r7,#0xf]          ;115  ; g_au8SlaveRxBuffer
00005e  2836              CMP      r0,#0x36              ;115
000060  d109              BNE      |L10.118|
000062  2055              MOVS     r0,#0x55              ;118
000064  7020              STRB     r0,[r4,#0]            ;118
000066  2066              MOVS     r0,#0x66              ;119
000068  73e0              STRB     r0,[r4,#0xf]          ;119
00006a  2101              MOVS     r1,#1                 ;121
                  |L10.108|
00006c  5461              STRB     r1,[r4,r1]            ;123
00006e  1c49              ADDS     r1,r1,#1              ;123
000070  b289              UXTH     r1,r1                 ;121
000072  290f              CMP      r1,#0xf               ;121
000074  d3fa              BCC      |L10.108|
                  |L10.118|
000076  a02c              ADR      r0,|L10.296|
000078  f7fffffe          BL       __2printf
00007c  2700              MOVS     r7,#0                 ;129
                  |L10.126|
00007e  a028              ADR      r0,|L10.288|
000080  5de1              LDRB     r1,[r4,r7]            ;131
000082  f7fffffe          BL       __2printf
000086  0778              LSLS     r0,r7,#29             ;132
000088  f1b04f60          CMP      r0,#0xe0000000        ;132
00008c  d102              BNE      |L10.148|
00008e  a030              ADR      r0,|L10.336|
000090  f7fffffe          BL       __2printf
                  |L10.148|
000094  1c7f              ADDS     r7,r7,#1              ;134
000096  b2bf              UXTH     r7,r7                 ;129
000098  2f10              CMP      r7,#0x10              ;129
00009a  d3f0              BCC      |L10.126|
00009c  2310              MOVS     r3,#0x10              ;140
00009e  2200              MOVS     r2,#0                 ;140
0000a0  2102              MOVS     r1,#2                 ;140
0000a2  4630              MOV      r0,r6                 ;140
0000a4  f7fffffe          BL       PDMA_SetTransferCnt
0000a8  4814              LDR      r0,|L10.252|
0000aa  f44f6140          MOV      r1,#0xc00             ;141
0000ae  3020              ADDS     r0,r0,#0x20           ;141
0000b0  4a13              LDR      r2,|L10.256|
0000b2  e9cd0100          STRD     r0,r1,[sp,#0]         ;141
0000b6  2300              MOVS     r3,#0                 ;141
0000b8  3a20              SUBS     r2,r2,#0x20           ;141
0000ba  2102              MOVS     r1,#2                 ;141
0000bc  4630              MOV      r0,r6                 ;141
0000be  f7fffffe          BL       PDMA_SetTransferAddr
0000c2  2300              MOVS     r3,#0                 ;143
0000c4  2214              MOVS     r2,#0x14              ;143
0000c6  2102              MOVS     r1,#2                 ;143
0000c8  4630              MOV      r0,r6                 ;143
0000ca  f8cd8000          STR      r8,[sp,#0]            ;143
0000ce  f7fffffe          BL       PDMA_SetTransferMode
0000d2  68e8              LDR      r0,[r5,#0xc]          ;144
0000d4  f0400001          ORR      r0,r0,#1              ;144
0000d8  60e8              STR      r0,[r5,#0xc]          ;144
;;;161                {
;;;162                    printf("\r\n");
;;;163                }			
;;;164    		}
;;;165    		#endif
;;;166    
;;;167    		QSPI_Slave_PDMA_ClrBuffer(QSPI_RX);	
;;;168    	}
;;;169    }
0000da  e8bd81fc          POP      {r2-r8,pc}
                  |L10.222|
0000de  a01c              ADR      r0,|L10.336|
0000e0  f7fffffe          BL       __2printf
                  |L10.228|
0000e4  1c64              ADDS     r4,r4,#1              ;162
0000e6  b2a4              UXTH     r4,r4                 ;157
0000e8  2c10              CMP      r4,#0x10              ;157
0000ea  d3a6              BCC      |L10.58|
0000ec  e8bd41fc          POP      {r2-r8,lr}            ;167
0000f0  2001              MOVS     r0,#1                 ;167
0000f2  f7ffbffe          B.W      QSPI_Slave_PDMA_ClrBuffer
;;;170    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L10.248|
                          DCD      0x40008000
                  |L10.252|
                          DCD      0x40060000
                  |L10.256|
                          DCD      ||.bss||+0x30
                  |L10.260|
000104  0d0a675f          DCB      "\r\ng_au8SlaveRxBuffer : \r\n",0
000108  61753853
00010c  6c617665
000110  52784275
000114  66666572
000118  203a200d
00011c  0a00    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L10.288|
000120  30782532          DCB      "0x%2X,",0
000124  582c00  
000127  00                DCB      0
                  |L10.296|
000128  0d0a675f          DCB      "\r\ng_au8SlaveToMasterTestPattern : \r\n",0
00012c  61753853
000130  6c617665
000134  546f4d61
000138  73746572
00013c  54657374
000140  50617474
000144  65726e20
000148  3a200d0a
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L10.336|
000150  0d0a00            DCB      "\r\n",0
000153  00                DCB      0

                          AREA ||i.QSPI_Slave_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  QSPI_Slave_PDMA_PreInit PROC
;;;66     
;;;67     void QSPI_Slave_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;68     {
;;;69     	QSPI_Slave_PDMA_ClrBuffer(QSPI_TX);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
;;;70     	QSPI_Slave_PDMA_ClrBuffer(QSPI_RX);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       QSPI_Slave_PDMA_ClrBuffer
;;;71     	
;;;72         PDMA_Open(PDMA, QSPI_SLAVE_OPENED_CH);
00000e  4c32              LDR      r4,|L11.216|
000010  210c              MOVS     r1,#0xc
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       PDMA_Open
;;;73     
;;;74     	//RX
;;;75         PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000018  2310              MOVS     r3,#0x10
00001a  2200              MOVS     r2,#0
00001c  2103              MOVS     r1,#3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       PDMA_SetTransferCnt
;;;76         /* Set source/destination address and attributes */
;;;77         PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_RX_DMA_CH, (uint32_t)&QSPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8SlaveRxBuffer, PDMA_DAR_INC);
000024  2500              MOVS     r5,#0
000026  482d              LDR      r0,|L11.220|
000028  e9cd0500          STRD     r0,r5,[sp,#0]
00002c  f44f7340          MOV      r3,#0x300
000030  4a2b              LDR      r2,|L11.224|
000032  2103              MOVS     r1,#3
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       PDMA_SetTransferAddr
;;;78         /* Set request source; set basic mode. */
;;;79         PDMA_SetTransferMode(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_QSPI0_RX, FALSE, 0);
00003a  2300              MOVS     r3,#0
00003c  2215              MOVS     r2,#0x15
00003e  2103              MOVS     r1,#3
000040  4620              MOV      r0,r4
000042  9500              STR      r5,[sp,#0]
000044  f7fffffe          BL       PDMA_SetTransferMode
;;;80         /* Single request type. SPI only support PDMA single request type. */
;;;81         PDMA_SetBurstType(PDMA,QSPI_SLAVE_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000048  2300              MOVS     r3,#0
00004a  2204              MOVS     r2,#4
00004c  2103              MOVS     r1,#3
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       PDMA_SetBurstType
;;;82         /* Disable table interrupt */
;;;83         PDMA->DSCT[QSPI_SLAVE_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000054  6b20              LDR      r0,[r4,#0x30]
000056  f0400080          ORR      r0,r0,#0x80
00005a  6320              STR      r0,[r4,#0x30]
;;;84     
;;;85     	//TX
;;;86         PDMA_SetTransferCnt(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
00005c  2310              MOVS     r3,#0x10
00005e  2200              MOVS     r2,#0
000060  2102              MOVS     r1,#2
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       PDMA_SetTransferCnt
;;;87         /* Set source/destination address and attributes */
;;;88         PDMA_SetTransferAddr(PDMA,QSPI_SLAVE_TX_DMA_CH, (uint32_t)g_au8SlaveToMasterTestPattern, PDMA_SAR_INC, (uint32_t)&QSPI0->TX, PDMA_DAR_FIX);
000068  481d              LDR      r0,|L11.224|
00006a  f44f6140          MOV      r1,#0xc00
00006e  3810              SUBS     r0,r0,#0x10
000070  4a1a              LDR      r2,|L11.220|
000072  e9cd0100          STRD     r0,r1,[sp,#0]
000076  2300              MOVS     r3,#0
000078  3a20              SUBS     r2,r2,#0x20
00007a  2102              MOVS     r1,#2
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       PDMA_SetTransferAddr
;;;89         /* Set request source; set basic mode. */
;;;90         PDMA_SetTransferMode(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_QSPI0_TX, FALSE, 0);
000082  2300              MOVS     r3,#0
000084  2214              MOVS     r2,#0x14
000086  2102              MOVS     r1,#2
000088  4620              MOV      r0,r4
00008a  9500              STR      r5,[sp,#0]
00008c  f7fffffe          BL       PDMA_SetTransferMode
;;;91         /* Single request type. SPI only support PDMA single request type. */
;;;92         PDMA_SetBurstType(PDMA,QSPI_SLAVE_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000090  2300              MOVS     r3,#0
000092  2204              MOVS     r2,#4
000094  2102              MOVS     r1,#2
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       PDMA_SetBurstType
;;;93         /* Disable table interrupt */
;;;94         PDMA->DSCT[QSPI_SLAVE_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00009c  6a20              LDR      r0,[r4,#0x20]
00009e  f0400080          ORR      r0,r0,#0x80
0000a2  6220              STR      r0,[r4,#0x20]
;;;95     
;;;96         QSPI_TRIGGER_RX_PDMA(QSPI0);
0000a4  480e              LDR      r0,|L11.224|
0000a6  3830              SUBS     r0,r0,#0x30
0000a8  68c1              LDR      r1,[r0,#0xc]
0000aa  f0410102          ORR      r1,r1,#2
0000ae  60c1              STR      r1,[r0,#0xc]
;;;97         QSPI_TRIGGER_TX_PDMA(QSPI0);
0000b0  68c1              LDR      r1,[r0,#0xc]
0000b2  f0410101          ORR      r1,r1,#1
0000b6  60c1              STR      r1,[r0,#0xc]
;;;98     
;;;99         PDMA_EnableInt(PDMA, QSPI_SLAVE_TX_DMA_CH, PDMA_INT_TRANS_DONE);
0000b8  2200              MOVS     r2,#0
0000ba  2102              MOVS     r1,#2
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       PDMA_EnableInt
;;;100        PDMA_EnableInt(PDMA, QSPI_SLAVE_RX_DMA_CH, PDMA_INT_TRANS_DONE);
0000c2  2200              MOVS     r2,#0
0000c4  2103              MOVS     r1,#3
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       PDMA_EnableInt
;;;101        NVIC_EnableIRQ(PDMA_IRQn);	
0000cc  e8bd407c          POP      {r2-r6,lr}
0000d0  2028              MOVS     r0,#0x28
0000d2  f7ffbffe          B.W      NVIC_EnableIRQ
;;;102    	
;;;103    }
;;;104    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L11.216|
                          DCD      0x40008000
                  |L11.220|
                          DCD      ||.bss||+0x30
                  |L11.224|
                          DCD      0x40060030

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;470    
;;;471    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L12.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L12.10|
;;;472    {
;;;473        /*---------------------------------------------------------------------------------------------------------*/
;;;474        /* Init System Clock                                                                                       */
;;;475        /*---------------------------------------------------------------------------------------------------------*/
;;;476        /* Unlock protected registers */
;;;477        SYS_UnlockReg();
;;;478    
;;;479        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;480        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;481    
;;;482        /* Enable External XTAL (4~24 MHz) */
;;;483        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;484    
;;;485        /* Waiting for 12MHz clock ready */
;;;486        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;487    
;;;488        /* Set core clock as PLL_CLOCK from PLL */
;;;489        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481c              LDR      r0,|L12.172|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;490        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;491        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;492    
;;;493        /* Enable UART clock */
;;;494        CLK_EnableModuleClock(UART0_MODULE);
000046  4e1a              LDR      r6,|L12.176|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;495    
;;;496        /* Select UART clock source from HXT */
;;;497        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;498    
;;;499        CLK_SetModuleClock(QSPI0_MODULE, CLK_CLKSEL2_QSPI0SEL_PCLK0, MODULE_NoMsk);
000058  4e16              LDR      r6,|L12.180|
00005a  2200              MOVS     r2,#0
00005c  2108              MOVS     r1,#8
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;500        CLK_EnableModuleClock(QSPI0_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;501    
;;;502        CLK_EnableModuleClock(PDMA_MODULE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       CLK_EnableModuleClock
;;;503    
;;;504    //	TIMER0_HW_Init();
;;;505    	TIMER1_HW_Init();
000070  f7fffffe          BL       TIMER1_HW_Init
;;;506    	
;;;507        /* Update System Core Clock */
;;;508        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;509        SystemCoreClockUpdate();
000074  f7fffffe          BL       SystemCoreClockUpdate
;;;510    
;;;511        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;512        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000078  6be0              LDR      r0,[r4,#0x3c]
00007a  f420007f          BIC      r0,r0,#0xff0000
00007e  63e0              STR      r0,[r4,#0x3c]
;;;513        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000080  6be0              LDR      r0,[r4,#0x3c]
000082  f44000cc          ORR      r0,r0,#0x660000
000086  63e0              STR      r0,[r4,#0x3c]
;;;514    
;;;515        /* Setup QSPI0 multi-function pins */
;;;516        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_QSPI0_MOSI0 | SYS_GPA_MFPL_PA1MFP_QSPI0_MISO0 | SYS_GPA_MFPL_PA2MFP_QSPI0_CLK | SYS_GPA_MFPL_PA3MFP_QSPI0_SS |
000088  6b20              LDR      r0,[r4,#0x30]
00008a  490b              LDR      r1,|L12.184|
00008c  4308              ORRS     r0,r0,r1
00008e  6320              STR      r0,[r4,#0x30]
;;;517                         SYS_GPA_MFPL_PA4MFP_QSPI0_MOSI1 | SYS_GPA_MFPL_PA5MFP_QSPI0_MISO1;
;;;518    
;;;519        /* Enable QSPI0 clock pin (PA2) schmitt trigger */
;;;520        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
000090  6a68              LDR      r0,[r5,#0x24]
000092  f0400004          ORR      r0,r0,#4
000096  6268              STR      r0,[r5,#0x24]
;;;521    
;;;522        /* Enable QSPI0 I/O high slew rate */
;;;523        GPIO_SetSlewCtl(PA, 0x3F, GPIO_SLEWCTL_HIGH);
000098  2201              MOVS     r2,#1
00009a  213f              MOVS     r1,#0x3f
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       GPIO_SetSlewCtl
0000a2  2000              MOVS     r0,#0
0000a4  f8c40100          STR      r0,[r4,#0x100]
;;;524    	
;;;525        /* Lock protected registers */
;;;526        SYS_LockReg();
;;;527    }
0000a8  bd70              POP      {r4-r6,pc}
;;;528    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L12.172|
                          DCD      0x0b71b000
                  |L12.176|
                          DCD      0x57803d10
                  |L12.180|
                          DCD      0x6620000c
                  |L12.184|
                          DCD      0x00333333

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;451    
;;;452    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;453    {
;;;454    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L13.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;455    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;456    }
;;;457    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;457    
;;;458    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;459    {
;;;460    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L14.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;461    }
;;;462    
                          ENDP

                  |L14.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;437    
;;;438    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;439    {
;;;440        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L15.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;441        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;442    }
;;;443    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;443    
;;;444    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L16.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;447        TIMER_EnableInt(TIMER1);
;;;448        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;449        TIMER_Start(TIMER1);
;;;450    }
000028  bd10              POP      {r4,pc}
;;;451    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR1_IRQHandler PROC
;;;419    
;;;420    void TMR1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  480f              LDR      r0,|L17.64|
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
;;;421    {
00000a  2900              CMP      r1,#0
00000c  d016              BEQ      |L17.60|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;422    	static uint16_t CNT = 0;	
;;;423    	static uint32_t log = 0;	
;;;424    	
;;;425        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;426        {
;;;427            TIMER_ClearIntFlag(TIMER1);
;;;428    	
;;;429    		if (CNT++ > 1000)
000012  490c              LDR      r1,|L17.68|
000014  8848              LDRH     r0,[r1,#2]  ; CNT
000016  1c42              ADDS     r2,r0,#1
000018  804a              STRH     r2,[r1,#2]
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d90d              BLS      |L17.60|
;;;430    		{		
;;;431    			CNT = 0;
000020  2000              MOVS     r0,#0
000022  8048              STRH     r0,[r1,#2]
;;;432    			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
000024  684a              LDR      r2,[r1,#4]  ; log
000026  1c50              ADDS     r0,r2,#1
000028  6048              STR      r0,[r1,#4]  ; log
00002a  4907              LDR      r1,|L17.72|
00002c  a007              ADR      r0,|L17.76|
00002e  f7fffffe          BL       __2printf
;;;433    			LED_R ^= 1;
000032  4809              LDR      r0,|L17.88|
000034  6801              LDR      r1,[r0,#0]
000036  f0810101          EOR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L17.60|
;;;434    		}
;;;435        }
;;;436    }
00003c  bd10              POP      {r4,pc}
;;;437    
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      0x40050100
                  |L17.68|
                          DCD      ||.data||
                  |L17.72|
                          DCD      ||.constdata||
                  |L17.76|
00004c  2573203a          DCB      "%s : %2d\r\n",0
000050  20253264
000054  0d0a00  
000057  00                DCB      0
                  |L17.88|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;536    
;;;537    int main()
000000  f7fffffe          BL       SYS_Init
;;;538    {
;;;539    	
;;;540        SYS_Init();
;;;541        /* Init UART to 115200-8n1 for print message */
;;;542        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  4814              LDR      r0,|L18.92|
00000a  f7fffffe          BL       UART_Open
;;;543    
;;;544    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a012              ADR      r0,|L18.96|
000016  f7fffffe          BL       __2printf
;;;545    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a016              ADR      r0,|L18.124|
000022  f7fffffe          BL       __2printf
;;;546    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a019              ADR      r0,|L18.148|
00002e  f7fffffe          BL       __2printf
;;;547    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a01c              ADR      r0,|L18.172|
00003a  f7fffffe          BL       __2printf
;;;548    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a020              ADR      r0,|L18.200|
000046  f7fffffe          BL       __2printf
;;;549    
;;;550    	LED_Init();
00004a  f7fffffe          BL       LED_Init
;;;551    	TIMER1_Init();
00004e  f7fffffe          BL       TIMER1_Init
;;;552    
;;;553    	#if defined (ENABLE_QSPI_MASTER)
;;;554    	
;;;555    	QSPI_Master_Init();
000052  f7fffffe          BL       QSPI_Master_Init
;;;556    	QSPI_Master_PDMA_PreInit();
000056  f7fffffe          BL       QSPI_Master_PDMA_PreInit
                  |L18.90|
;;;557    	
;;;558    	#elif defined (ENABLE_QSPI_SLAVE)
;;;559    	
;;;560    	QSPI_Slave_Init();
;;;561    	QSPI_Slave_PDMA_PreInit();
;;;562    
;;;563    	#endif
;;;564    
;;;565        /* Got no where to go, just loop forever */
;;;566        while(1)
00005a  e7fe              B        |L18.90|
;;;567        {
;;;568    //		TIMER0_Polling(100);
;;;569    		
;;;570    
;;;571        }
;;;572    
;;;573    }
;;;574    
                          ENDP

                  |L18.92|
                          DCD      0x40070000
                  |L18.96|
000060  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000064  4b5f4765
000068  74435055
00006c  46726571
000070  203a2025
000074  38640d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L18.124|
00007c  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000080  47657448
000084  58544672
000088  6571203a
00008c  20253864
000090  0d0a00  
000093  00                DCB      0
                  |L18.148|
000094  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000098  4765744c
00009c  58544672
0000a0  6571203a
0000a4  20253864
0000a8  0d0a00  
0000ab  00                DCB      0
                  |L18.172|
0000ac  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b0  47657450
0000b4  434c4b30
0000b8  46726571
0000bc  203a2025
0000c0  38640d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L18.200|
0000c8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000cc  47657450
0000d0  434c4b31
0000d4  46726571
0000d8  203a2025
0000dc  38640d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8MasterToSlaveTestPattern
                          %        16
                  g_au8SlaveToMasterTestPattern
                          %        16
                  g_au8MasterRxBuffer
                          %        16
                  g_au8SlaveRxBuffer
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5231          DCB      0x54,0x4d,0x52,0x31
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  j
000000  0000              DCW      0x0000
                  ||CNT||
000002  0000              DCW      0x0000
                  log
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_468c6c6b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REVSH|
#line 402
|__asm___6_main_c_468c6c6b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____RRX|
#line 587
|__asm___6_main_c_468c6c6b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
